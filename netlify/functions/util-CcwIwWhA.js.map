{"version":3,"file":"util-CcwIwWhA.js","names":[],"sources":["../../lib/routes/tmtpost/util.ts"],"sourcesContent":["import { type Data, type DataItem } from '@/types';\r\n\r\nimport { art } from '@/utils/render';\r\nimport cache from '@/utils/cache';\r\nimport ofetch from '@/utils/ofetch';\r\nimport { parseDate } from '@/utils/parse-date';\r\n\r\nimport { type CheerioAPI, load } from 'cheerio';\r\nimport path from 'node:path';\r\n\r\nconst baseUrl: string = 'https://www.tmtpost.com';\r\nconst apiBaseUrl: string = 'https://api.tmtpost.com';\r\nconst postApiUrl: string = new URL('v1/posts/', apiBaseUrl).href;\r\n\r\nconst headers = {\r\n    'app-version': 'web1.0',\r\n};\r\n\r\nconst processItems = async (limit: number, query: Record<string, any>, apiUrl: string, targetUrl: string): Promise<Data> => {\r\n    const response = await ofetch(apiUrl, {\r\n        query: {\r\n            limit,\r\n            ...query,\r\n        },\r\n        headers,\r\n    });\r\n\r\n    const targetResponse = await ofetch(targetUrl);\r\n    const $: CheerioAPI = load(targetResponse);\r\n    const language = $('html').attr('lang') ?? 'zh-CN';\r\n\r\n    let items: DataItem[] = [];\r\n\r\n    items = response.data.slice(0, limit).map((item): DataItem => {\r\n        const title: string = item.title;\r\n        const description: string = art(path.join(__dirname, 'templates/description.art'), {\r\n            intro: item.summary,\r\n        });\r\n        const pubDate: number | string = item.time_published;\r\n        const linkUrl: string | undefined = item.share_link;\r\n        const guid: string = item.guid;\r\n        const image: string | undefined = item.thumb_image?.original?.url;\r\n        const updated: number | string = item.updated ?? pubDate;\r\n\r\n        const processedItem: DataItem = {\r\n            title,\r\n            description,\r\n            pubDate: pubDate ? parseDate(pubDate, 'X') : undefined,\r\n            link: linkUrl,\r\n            guid,\r\n            id: guid,\r\n            content: {\r\n                html: description,\r\n                text: item.content ?? description,\r\n            },\r\n            image,\r\n            banner: image,\r\n            updated: updated ? parseDate(updated, 'X') : undefined,\r\n            language,\r\n        };\r\n\r\n        return processedItem;\r\n    });\r\n\r\n    items = (\r\n        await Promise.all(\r\n            items.map((item) => {\r\n                if (!item.link) {\r\n                    return item;\r\n                }\r\n\r\n                return cache.tryGet(item.link, async (): Promise<DataItem> => {\r\n                    const detailApiUrl: string = new URL(item.guid as string, postApiUrl).href;\r\n\r\n                    const detailResponse = await ofetch(detailApiUrl, {\r\n                        query: {\r\n                            fields: ['authors', 'tags', 'featured_image', 'categories', 'stock_list', 'big_plate', 'concept_plate', 'plate', 'plate_list', 'share_link'].join(';'),\r\n                        },\r\n                        headers,\r\n                    });\r\n                    const data = detailResponse.data;\r\n\r\n                    if (!data) {\r\n                        return item;\r\n                    }\r\n\r\n                    const title: string = data.title;\r\n                    const description: string = art(path.join(__dirname, 'templates/description.art'), {\r\n                        intro: data.summary,\r\n                        description: data.main,\r\n                    });\r\n                    const pubDate: number | string = data.time_published;\r\n                    const linkUrl: string | undefined = data.share_link;\r\n                    const categories: string[] = [\r\n                        ...new Set(\r\n                            (\r\n                                [...(data.categories ?? []), ...(data.stock_list ?? []), ...(data.big_plate ?? []), ...(data.concept_plate ?? []), ...(data.plate ?? []), ...(data.plate_list ?? []), ...(data.tags ?? [])].map(\r\n                                    (c) => c.title ?? c.name ?? c.tag\r\n                                ) as string[]\r\n                            ).filter(Boolean)\r\n                        ),\r\n                    ];\r\n                    const authors: DataItem['author'] = data.authors?.map((author) => ({\r\n                        name: author.username,\r\n                        url: new URL(`user/${author.guid}`, baseUrl).href,\r\n                        avatar: author.avatar,\r\n                    }));\r\n                    const guid: string = `tmtpost-${data.post_guid}`;\r\n                    const image: string | undefined = data.images?.[0]?.url;\r\n                    const updated: number | string = data.time_updated;\r\n\r\n                    let processedItem: DataItem = {\r\n                        title,\r\n                        description,\r\n                        pubDate: pubDate ? parseDate(pubDate, 'X') : undefined,\r\n                        link: linkUrl ?? item.link,\r\n                        category: categories,\r\n                        author: authors,\r\n                        guid,\r\n                        id: guid,\r\n                        content: {\r\n                            html: description,\r\n                            text: description,\r\n                        },\r\n                        image,\r\n                        banner: image,\r\n                        updated: updated ? parseDate(updated, 'X') : undefined,\r\n                        language,\r\n                    };\r\n\r\n                    const enclosureUrl: string | undefined = data.audio;\r\n\r\n                    if (enclosureUrl) {\r\n                        const enclosureType: string = `audio/${enclosureUrl.split(/\\./).pop()}`;\r\n                        const itunesDuration: string | number | undefined = data.duration;\r\n\r\n                        processedItem = {\r\n                            ...processedItem,\r\n                            enclosure_url: enclosureUrl,\r\n                            enclosure_type: enclosureType,\r\n                            enclosure_title: title,\r\n                            enclosure_length: undefined,\r\n                            itunes_duration: itunesDuration,\r\n                            itunes_item_image: image,\r\n                        };\r\n                    }\r\n\r\n                    const medias: Record<string, Record<string, string>> = {};\r\n\r\n                    if (data.full_size_images ?? data.images) {\r\n                        const images = data.full_size_images ?? data.images;\r\n                        for (const media of images) {\r\n                            const url: string | undefined = media.url ?? media;\r\n\r\n                            if (!url) {\r\n                                continue;\r\n                            }\r\n\r\n                            const medium: string = 'image';\r\n                            const count: number = Object.values(medias).filter((m) => m.medium === medium).length + 1;\r\n                            const key: string = `${medium}${count}`;\r\n\r\n                            medias[key] = {\r\n                                url,\r\n                                medium,\r\n                                title,\r\n                                thumbnail: media.thumbnail ?? url,\r\n                            };\r\n                        }\r\n                    }\r\n\r\n                    processedItem = {\r\n                        ...processedItem,\r\n                        media: medias,\r\n                    };\r\n\r\n                    return {\r\n                        ...item,\r\n                        ...processedItem,\r\n                    };\r\n                });\r\n            })\r\n        )\r\n    ).filter((_): _ is DataItem => true);\r\n\r\n    const title: string = $('title').text();\r\n    const author: string | undefined = title.split(/-/).pop();\r\n\r\n    return {\r\n        title,\r\n        description: $('meta[property=\"og:description\"]').attr('content'),\r\n        link: targetUrl,\r\n        item: items,\r\n        allowEmpty: true,\r\n        image: $('meta[property=\"og:image\"]').attr('content'),\r\n        author: title.split(/-/).pop(),\r\n        language,\r\n        itunes_author: author,\r\n        itunes_category: 'Technology',\r\n        id: targetUrl,\r\n    };\r\n};\r\n\r\nexport { baseUrl, apiBaseUrl, processItems };\r\n"],"mappings":"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"}