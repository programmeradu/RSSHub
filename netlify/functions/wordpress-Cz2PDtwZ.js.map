{"version":3,"file":"wordpress-Cz2PDtwZ.js","names":["filterKeys: Record<string, string>","filterApiKeys: Record<string, string | undefined>","filterPairs","key","filters","response","got","ConfigNotFoundError","got","parser","route: Route"],"sources":["../../lib/routes/wordpress/util.ts","../../lib/routes/wordpress/index.ts"],"sourcesContent":["import got from '@/utils/got';\r\nimport { load } from 'cheerio';\r\n\r\nconst apiSlug = 'wp-json/wp/v2';\r\n\r\ninterface Filter {\r\n    id: string;\r\n    name: string;\r\n    slug: string;\r\n}\r\n\r\nconst filterKeys: Record<string, string> = {\r\n    search: 's',\r\n};\r\n\r\nconst filterApiKeys: Record<string, string | undefined> = {\r\n    category: 'categories',\r\n    tag: 'tags',\r\n    search: undefined,\r\n};\r\n\r\nconst filterApiKeysWithNoId = new Set(['search']);\r\n\r\n/**\r\n * Bake filter search parameters.\r\n *\r\n * @param filterPairs - The filter pairs object.\r\n *                      e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n * @param pairKey - The filter pair key.\r\n *                  e.g. `{ id: ..., name: ..., slug: ... }`.\r\n * @param isApi - Indicates if the search parameters are for API.\r\n * @returns The baked filter search parameters.\r\n */\r\nconst bakeFilterSearchParams = (filterPairs: Record<string, Filter[] | string[]>, pairKey: string, isApi: boolean = false): URLSearchParams => {\r\n    /**\r\n     * Bake filters recursively.\r\n     *\r\n     * @param filterPairs - The filter pairs object.\r\n     *                      e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n     * @param filterSearchParams - The filter search parameters.\r\n     *                             e.g. `category=a,b&tag=c`.\r\n     * @returns The baked filter search parameters.\r\n     *          e.g. `category=a,b&tag=c`.\r\n     */\r\n    const bakeFilters = (filterPairs: Record<string, Filter[] | string[]>, filterSearchParams: URLSearchParams): URLSearchParams => {\r\n        const keys = Object.keys(filterPairs).filter((key) => filterPairs[key]?.length > 0 && (isApi ? Object.hasOwn(filterApiKeys, key) : Object.hasOwn(filterKeys, key)));\r\n\r\n        if (keys.length === 0) {\r\n            return filterSearchParams;\r\n        }\r\n\r\n        const key = keys[0];\r\n        const pairs = filterPairs[key];\r\n\r\n        const originalFilters = { ...filterPairs };\r\n        delete originalFilters[key];\r\n\r\n        const filterKey = getFilterKeyForSearchParams(key, isApi);\r\n        const pairValues = pairs.map((pair) => (Object.hasOwn(pair, pairKey) ? pair[pairKey] : pair));\r\n\r\n        if (filterKey) {\r\n            filterSearchParams.append(filterKey, pairValues.join(','));\r\n        }\r\n\r\n        return bakeFilters(originalFilters, filterSearchParams);\r\n    };\r\n\r\n    return bakeFilters(filterPairs, new URLSearchParams());\r\n};\r\n\r\n/**\r\n * Bake filters with pair.\r\n *\r\n * @param filters - The filters object.\r\n *                  e.g. `{ category: [ a, b ], tag: [ c ] }`.\r\n * @returns The baked filters.\r\n *          e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n */\r\nconst bakeFiltersWithPair = async (filters: Record<string, string[]>, rootUrl: string) => {\r\n    /**\r\n     * Bake keywords recursively.\r\n     *\r\n     * @param key - The key.\r\n     *              e.g. `category` or `tag`.\r\n     * @param keywords - The keywords.\r\n     *                   e.g. `[ a, b ]`.\r\n     * @returns The baked keywords.\r\n     *          e.g. `[ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ]`.\r\n     */\r\n    const bakeKeywords = async (key: string, keywords: string[]) => {\r\n        if (keywords.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        const [keyword, ...rest] = keywords;\r\n\r\n        const filter = await getFilterByKeyAndKeyword(key, keyword, rootUrl);\r\n\r\n        return [\r\n            ...(filter?.id && filter?.slug\r\n                ? [\r\n                      {\r\n                          id: filter.id,\r\n                          name: filter.name,\r\n                          slug: filter.slug,\r\n                      },\r\n                  ]\r\n                : []),\r\n            ...(await bakeKeywords(key, rest)),\r\n        ];\r\n    };\r\n\r\n    /**\r\n     * Bake filters recursively.\r\n     *\r\n     * @param filters - The filters object.\r\n     *                  e.g. `{ category: [ a, b ], tag: [ c ] }`.\r\n     * @param filtersWithPair - The filters with pairs.\r\n     *                          e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n     * @returns The baked filters.\r\n     *          e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n     */\r\n    const bakeFilters = async (filters: Record<string, string[]>, filtersWithPair: Record<string, Filter[]>) => {\r\n        const keys = Object.keys(filters);\r\n\r\n        if (keys.length === 0) {\r\n            return filtersWithPair;\r\n        }\r\n\r\n        const key = keys[0];\r\n        const keywords = filters[key];\r\n\r\n        const originalFilters = { ...filters };\r\n        delete originalFilters[key];\r\n\r\n        return bakeFilters(originalFilters, {\r\n            ...filtersWithPair,\r\n            [key]: filterApiKeysWithNoId.has(key) ? keywords : await bakeKeywords(key, keywords),\r\n        });\r\n    };\r\n\r\n    return await bakeFilters(filters, {});\r\n};\r\n\r\n/**\r\n * Bake URL with search parameters.\r\n *\r\n * @param url - The URL.\r\n * @param rootUrl - The root URL.\r\n * @param searchParams - The search parameters.\r\n * @returns The baked URL.\r\n */\r\nconst bakeUrl = (url: string, rootUrl: string, searchParams: URLSearchParams = new URLSearchParams()): string => {\r\n    const searchParamsStr = searchParams.toString();\r\n    const searchParamsSuffix = searchParamsStr ? `?${searchParamsStr}` : '';\r\n\r\n    return `${rootUrl}/${url}${searchParamsSuffix}`;\r\n};\r\n\r\n/**\r\n * Fetch data from the specified URL.\r\n *\r\n * @param url - The URL to fetch data from.\r\n * @param rootUrl - The root URL.\r\n * @returns A promise that resolves to an object containing the fetched data to be added into `ctx.state.data`.\r\n */\r\nconst fetchData = async (url: string, rootUrl: string): Promise<object> => {\r\n    /**\r\n     * Request URLs recursively.\r\n     *\r\n     * @param urls - The URLs to request.\r\n     * @returns A promise that resolves to the response data or undefined if no response is available.\r\n     */\r\n    const requestUrls = async (urls: string[]): Promise<string | undefined> => {\r\n        if (urls.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const [currentUrl, ...remainingUrls] = urls;\r\n        try {\r\n            const { data: response } = await got.get(currentUrl);\r\n            return response;\r\n        } catch {\r\n            return requestUrls(remainingUrls);\r\n        }\r\n    };\r\n\r\n    const response = await requestUrls([url, rootUrl]);\r\n\r\n    if (!response) {\r\n        return {};\r\n    }\r\n\r\n    const $ = load(response);\r\n\r\n    const title = $('title').first().text();\r\n    const image = new URL($('link[rel=\"icon\"]').last().attr('href') ?? 'wp-content/uploads/site_logo.png', rootUrl).href;\r\n\r\n    return {\r\n        title,\r\n        description: $('meta[property=\"og:description\"]').attr('content') || $('meta[name=\"description\"]').attr('content'),\r\n        link: url,\r\n        allowEmpty: true,\r\n        image,\r\n        author: $('meta[property=\"og:site_name\"]').attr('content'),\r\n        language: $('html').attr('lang'),\r\n    };\r\n};\r\n\r\n/**\r\n * Get filter by key and keyword.\r\n *\r\n * @param key - The key.\r\n *              e.g. `category` or `tag`.\r\n * @param keyword - The keywords.\r\n *                  e.g. `keyword1`.\r\n * @returns A promise that resolves to the filter object if found, or undefined if not found.\r\n */\r\nconst getFilterByKeyAndKeyword = async (key: string, keyword: string, rootUrl: string): Promise<Filter | undefined> => {\r\n    const apiFilterUrl = `${rootUrl}/${apiSlug}/${getFilterKeyForSearchParams(key, true)}`;\r\n\r\n    const { data: response } = await got(apiFilterUrl, {\r\n        searchParams: {\r\n            search: keyword,\r\n        },\r\n    });\r\n\r\n    return response.length > 0 ? response[0] : undefined;\r\n};\r\n\r\n/**\r\n * Get filter key for search parameters.\r\n *\r\n * @param key - The key. e.g. `category` or `tag`.\r\n * @param isApi - Indicates whether the key is for the API.\r\n * @returns The filter key for search parameters, or undefined if not found.\r\n *          e.g. `categories` or `tags`.\r\n */\r\nconst getFilterKeyForSearchParams = (key: string, isApi: boolean = false): string | undefined => {\r\n    const keys = isApi ? filterApiKeys : filterKeys;\r\n\r\n    return Object.hasOwn(keys, key) ? (keys[key] ?? key) : undefined;\r\n};\r\n\r\n/**\r\n * Get filter parameters for URL.\r\n *\r\n * @param filterPairs - The filter pairs object.\r\n *                      e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n * @returns The filter parameters for the URL, or undefined if no filters are available.\r\n */\r\nconst getFilterParamsForUrl = (filterPairs: Record<string, Filter[]>): string | undefined => {\r\n    const keys = Object.keys(filterPairs).filter((key) => filterPairs[key].length > 0 && !Object.hasOwn(filterKeys, key));\r\n\r\n    if (keys.length === 0) {\r\n        return;\r\n    }\r\n\r\n    const key = keys[0];\r\n\r\n    return `${key}/${filterPairs[key].map((pair) => pair.slug).join('/')}`;\r\n};\r\n\r\n/**\r\n * Parses a filter string into a filters object.\r\n *\r\n * @param filterStr - The filter string to parse.\r\n *                    e.g. `category/a,b/tag/c`.\r\n * @returns The parsed filters object.\r\n *          e.g. `{ category: [ 'a', 'b' ], tag: [ 'c' ] }`.\r\n */\r\nconst parseFilterStr = (filterStr: string | undefined): Record<string, string[]> => {\r\n    /**\r\n     * Recursively parses a filter string.\r\n     *\r\n     * @param remainingStr - The remaining filter string to parse.\r\n     *                       e.g. `category/a,b/tag/c`.\r\n     * @param filters - The accumulated filters object.\r\n     *                  e.g. `{ category: [ a, b ], tag: [ c ] }`.\r\n     * @param currentKey - The current filter key.\r\n     *                     e.g. `category` or `tag`.\r\n     * @returns The parsed filters object.\r\n     */\r\n    const parseStr = (remainingStr: string | undefined, filters: Record<string, string[]> = {}, currentKey?: string): Record<string, string[]> => {\r\n        if (!remainingStr) {\r\n            return filters;\r\n        }\r\n\r\n        const [word, ...rest] = remainingStr.split(/\\/|,/);\r\n\r\n        const isKey = Object.hasOwn(filterApiKeys, word);\r\n        const key = isKey ? word : currentKey;\r\n\r\n        const newFilters = key\r\n            ? {\r\n                  ...filters,\r\n                  [key]: [...(filters[key] || []), ...(isKey ? [] : [word])],\r\n              }\r\n            : filters;\r\n\r\n        return parseStr(rest.join('/'), newFilters, key);\r\n    };\r\n\r\n    return parseStr(filterStr, {});\r\n};\r\n\r\nexport { apiSlug, bakeFilterSearchParams, bakeFiltersWithPair, bakeUrl, fetchData, getFilterParamsForUrl, parseFilterStr };\r\n","import { Route } from '@/types';\r\n\r\nimport got from '@/utils/got';\r\nimport { load } from 'cheerio';\r\nimport { parseDate } from '@/utils/parse-date';\r\nimport parser from '@/utils/rss-parser';\r\nimport { config } from '@/config';\r\nimport ConfigNotFoundError from '@/errors/types/config-not-found';\r\n\r\nimport { apiSlug, bakeFilterSearchParams, bakeFiltersWithPair, bakeUrl, fetchData, getFilterParamsForUrl, parseFilterStr } from './util';\r\n\r\nasync function handler(ctx) {\r\n    const { url = 'https://wordpress.org/news', filter } = ctx.req.param();\r\n    const limit = ctx.req.query('limit') ? Number.parseInt(ctx.req.query('limit'), 10) : 50;\r\n\r\n    if (!config.feature.allow_user_supply_unsafe_domain) {\r\n        throw new ConfigNotFoundError(`This RSS is disabled unless 'ALLOW_USER_SUPPLY_UNSAFE_DOMAIN' is set to 'true'.`);\r\n    }\r\n\r\n    if (!/^(https?):\\/\\/[^\\s#$./?].\\S*$/i.test(url)) {\r\n        throw new Error('Invalid URL');\r\n    }\r\n\r\n    const cdn = config.wordpress.cdnUrl;\r\n    const rootUrl = url;\r\n\r\n    const filters = parseFilterStr(filter);\r\n    const filtersWithPair = await bakeFiltersWithPair(filters, rootUrl);\r\n\r\n    const searchParams = bakeFilterSearchParams(filters, 'name', false);\r\n    const apiSearchParams = bakeFilterSearchParams(filtersWithPair, 'id', true);\r\n\r\n    apiSearchParams.append('_embed', 'true');\r\n    apiSearchParams.append('per_page', String(limit));\r\n\r\n    const apiUrl = bakeUrl(`${apiSlug}/posts`, rootUrl, apiSearchParams);\r\n    const currentUrl = bakeUrl(getFilterParamsForUrl(filtersWithPair) ?? '', rootUrl, searchParams);\r\n\r\n    try {\r\n        const { data: response } = await got(apiUrl);\r\n\r\n        const items = (Array.isArray(response) ? response : JSON.parse(response.match(/(\\[.*])$/)[1])).slice(0, limit).map((item) => {\r\n            const terminologies = item._embedded['wp:term'];\r\n            const guid = item.guid?.rendered ?? item.guid;\r\n\r\n            const $$ = load(item.content?.rendered ?? item.content);\r\n\r\n            $$('img').each((_, el) => {\r\n                el = $$(el);\r\n\r\n                const src = el.prop('src');\r\n\r\n                if (src.startsWith('/')) {\r\n                    el.prop('src', `${cdn}${item.link}${src}`);\r\n                } else if (src.startsWith('http:')) {\r\n                    el.prop('src', `${cdn}${src}`);\r\n                }\r\n            });\r\n\r\n            const description = $$.html();\r\n\r\n            return {\r\n                title: item.title?.rendered ?? item.title,\r\n                description,\r\n                pubDate: parseDate(item.date_gmt),\r\n                link: item.link,\r\n                category: [...new Set(terminologies.flat().map((c) => c.name))],\r\n                author: item._embedded.author.map((a) => a.name).join('/'),\r\n                guid,\r\n                id: guid,\r\n                content: {\r\n                    html: description,\r\n                    text: $$.text(),\r\n                },\r\n                updated: parseDate(item.modified_gmt),\r\n            };\r\n        });\r\n\r\n        const data = await fetchData(currentUrl, rootUrl);\r\n\r\n        return {\r\n            ...data,\r\n            item: items,\r\n        };\r\n    } catch {\r\n        const feed = await parser.parseURL(`${rootUrl}/feed/`);\r\n\r\n        const items = feed.items.map((item) => {\r\n            const guid = item.guid;\r\n\r\n            const $$ = load(item['content:encoded']);\r\n\r\n            $$('img').each((_, el) => {\r\n                el = $$(el);\r\n\r\n                const src = el.prop('src');\r\n\r\n                if (src.startsWith('/')) {\r\n                    el.prop('src', `${cdn}${item.link}${src}`);\r\n                } else if (src.startsWith('http:')) {\r\n                    el.prop('src', `${cdn}${src}`);\r\n                }\r\n            });\r\n\r\n            const description = $$.html();\r\n\r\n            return {\r\n                title: item.title,\r\n                description,\r\n                pubDate: parseDate(item.pubDate ?? ''),\r\n                link: item.link,\r\n                category: item.categories,\r\n                author: item.creator,\r\n                guid,\r\n                id: guid,\r\n                content: {\r\n                    html: description,\r\n                    text: $$.text(),\r\n                },\r\n            };\r\n        });\r\n\r\n        return {\r\n            title: feed.title,\r\n            description: feed.description,\r\n            link: feed.link,\r\n            item: items,\r\n            allowEmpty: true,\r\n            image: feed.image?.url,\r\n            language: feed.language,\r\n        };\r\n    }\r\n}\r\n\r\nexport const route: Route = {\r\n    path: '/:url?/:filter{.+}?',\r\n    name: 'WordPress',\r\n    url: 'wordpress.org',\r\n    maintainers: ['nczitzk'],\r\n    handler,\r\n    example: '/wordpress/https%3A%2F%2Fwordpress.org%2Fnews/category/Podcast',\r\n    parameters: { url: 'URL, <https://wordpress.org/news> by default', filter: 'Filter, see below' },\r\n    description: `If you subscribe to [WordPress News](https://wordpress.org/news/)，where the URL is \\`https://wordpress.org/news/\\`, Encode the URL using \\`encodeURIComponent()\\` and then use it as the parameter. Therefore, the route will be [\\`/wordpress/https%3A%2F%2Fwordpress.org%2Fnews\\`](https://rsshub.app/wordpress/https%3A%2F%2Fwordpress.org%2Fnews).\r\n\r\n::: tip\r\n  If you wish to subscribe to specific categories or tags, you can fill in the \"filter\" parameter in the route. \\`/category/Podcast\\` to subscribe to the Podcast category. In this case, the route would be [\\`/wordpress/https%3A%2F%2Fwordpress.org%2Fnews/category/Podcast\\`](https://rsshub.app/wordpress/https%3A%2F%2Fwordpress.org%2Fnews/category/Podcast).\r\n\r\n  You can also subscribe to multiple categories. \\`/category/Podcast,Community\\` to subscribe to both the Podcast and Community categories. In this case, the route would be [\\`/wordpress/https%3A%2F%2Fwordpress.org%2Fnews/category/Podcast,Community\\`](https://rsshub.app/wordpress/https%3A%2F%2Fwordpress.org%2Fnews/category/Podcast,Community).\r\n\r\n  Categories and tags can be combined as well. \\`/category/Releases/tag/tagging\\` to subscribe to the Releases category and the tagging tag. In this case, the route would be [\\`/wordpress/https%3A%2F%2Fwordpress.org%2Fnews/category/Releases/tag/tagging\\`](https://rsshub.app/wordpress/https%3A%2F%2Fwordpress.org%2Fnews/category/Releases/tag/tagging).\r\n  \r\n  You can also search for keywords. \\`/search/Blog\\` to search for the keyword \"Blog\". In this case, the route would be [\\`/wordpress/https%3A%2F%2Fwordpress.org%2Fnews/search/Blog\\`](https://rsshub.app/wordpress/https%3A%2F%2Fwordpress.org%2Fnews/search/Blog).\r\n:::`,\r\n    categories: ['blog'],\r\n\r\n    features: {\r\n        requireConfig: [\r\n            {\r\n                name: 'ALLOW_USER_SUPPLY_UNSAFE_DOMAIN',\r\n                description: `This RSS is disabled unless 'ALLOW_USER_SUPPLY_UNSAFE_DOMAIN' is set to 'true'.`,\r\n                optional: false,\r\n            },\r\n        ],\r\n        requirePuppeteer: false,\r\n        antiCrawler: false,\r\n        supportRadar: false,\r\n        supportBT: false,\r\n        supportPodcast: false,\r\n        supportScihub: false,\r\n    },\r\n    radar: [],\r\n};\r\n"],"mappings":"6cAGA,MAAM,EAAU,gBAQVA,EAAqC,CACvC,OAAQ,KAGNC,EAAoD,CACtD,SAAU,aACV,IAAK,OACL,OAAQ,IAAA,IAGN,EAAwB,IAAI,IAAI,CAAC,WAYjC,GAA0B,EAAkD,EAAiB,EAAiB,KAA2B,CAW3I,IAAM,GAAe,EAAkD,IAAyD,CAC5H,IAAM,EAAO,OAAO,KAAKC,GAAa,OAAQ,GAAQA,EAAYC,IAAM,OAAS,IAAM,EAAQ,OAAO,OAAO,EAAeA,GAAO,OAAO,OAAO,EAAYA,KAE7J,GAAI,EAAK,SAAW,EAChB,OAAO,EAGX,IAAM,EAAM,EAAK,GACX,EAAQD,EAAY,GAEpB,EAAkB,CAAE,GAAGA,GAC7B,OAAO,EAAgB,GAEvB,IAAM,EAAY,EAA4B,EAAK,GAC7C,EAAa,EAAM,IAAK,GAAU,OAAO,OAAO,EAAM,GAAW,EAAK,GAAW,GAMvF,OAJI,GACA,EAAmB,OAAO,EAAW,EAAW,KAAK,MAGlD,EAAY,EAAiB,IAGxC,OAAO,EAAY,EAAa,IAAI,kBAWlC,EAAsB,MAAO,EAAmC,IAAoB,CAWtF,IAAM,EAAe,MAAO,EAAa,IAAuB,CAC5D,GAAI,EAAS,SAAW,EACpB,MAAO,GAGX,GAAM,CAAC,EAAS,GAAG,GAAQ,EAErB,EAAS,MAAM,EAAyB,EAAK,EAAS,GAE5D,MAAO,CACH,GAAI,GAAQ,IAAM,GAAQ,KACpB,CACI,CACI,GAAI,EAAO,GACX,KAAM,EAAO,KACb,KAAM,EAAO,OAGrB,GACN,GAAI,MAAM,EAAa,EAAK,KAc9B,EAAc,MAAO,EAAmC,IAA8C,CACxG,IAAM,EAAO,OAAO,KAAKE,GAEzB,GAAI,EAAK,SAAW,EAChB,OAAO,EAGX,IAAM,EAAM,EAAK,GACX,EAAWA,EAAQ,GAEnB,EAAkB,CAAE,GAAGA,GAG7B,OAFA,OAAO,EAAgB,GAEhB,EAAY,EAAiB,CAChC,GAAG,GACF,GAAM,EAAsB,IAAI,GAAO,EAAW,MAAM,EAAa,EAAK,MAInF,OAAO,MAAM,EAAY,EAAS,KAWhC,GAAW,EAAa,EAAiB,EAAgC,IAAI,kBAA8B,CAC7G,IAAM,EAAkB,EAAa,WAC/B,EAAqB,EAAkB,IAAI,IAAoB,GAErE,MAAO,GAAG,EAAQ,GAAG,IAAM,KAUzB,EAAY,MAAO,EAAa,IAAqC,CAOvE,IAAM,EAAc,KAAO,IAAgD,CACvE,GAAI,EAAK,SAAW,EAChB,OAGJ,GAAM,CAAC,EAAY,GAAG,GAAiB,EACvC,GAAI,CACA,GAAM,CAAE,KAAMC,GAAa,MAAMG,EAAI,IAAI,GACzC,OAAOH,OACH,CACJ,OAAO,EAAY,KAIrB,EAAW,MAAM,EAAY,CAAC,EAAK,IAEzC,GAAI,CAAC,EACD,MAAO,GAGX,IAAM,EAAI,EAAK,GAET,EAAQ,EAAE,SAAS,QAAQ,OAC3B,EAAQ,IAAI,IAAI,EAAE,oBAAoB,OAAO,KAAK,SAAW,mCAAoC,GAAS,KAEhH,MAAO,CACH,QACA,YAAa,EAAE,mCAAmC,KAAK,YAAc,EAAE,4BAA4B,KAAK,WACxG,KAAM,EACN,WAAY,GACZ,QACA,OAAQ,EAAE,iCAAiC,KAAK,WAChD,SAAU,EAAE,QAAQ,KAAK,UAa3B,EAA2B,MAAO,EAAa,EAAiB,IAAiD,CACnH,IAAM,EAAe,GAAG,EAAQ,GAAG,EAAQ,GAAG,EAA4B,EAAK,MAEzE,CAAE,KAAM,GAAa,MAAMG,EAAI,EAAc,CAC/C,aAAc,CACV,OAAQ,KAIhB,OAAO,EAAS,OAAS,EAAI,EAAS,GAAK,IAAA,IAWzC,GAA+B,EAAa,EAAiB,KAA8B,CAC7F,IAAM,EAAO,EAAQ,EAAgB,EAErC,OAAO,OAAO,OAAO,EAAM,GAAQ,EAAK,IAAQ,EAAO,IAAA,IAUrD,EAAyB,GAA8D,CACzF,IAAM,EAAO,OAAO,KAAK,GAAa,OAAQ,GAAQ,EAAYL,GAAK,OAAS,GAAK,CAAC,OAAO,OAAO,EAAYA,IAEhH,GAAI,EAAK,SAAW,EAChB,OAGJ,IAAM,EAAM,EAAK,GAEjB,MAAO,GAAG,EAAI,GAAG,EAAY,GAAK,IAAK,GAAS,EAAK,MAAM,KAAK,QAW9D,EAAkB,GAA4D,CAYhF,IAAM,GAAY,EAAkC,EAAoC,GAAI,IAAkD,CAC1I,GAAI,CAAC,EACD,OAAO,EAGX,GAAM,CAAC,EAAM,GAAG,GAAQ,EAAa,MAAM,QAErC,EAAQ,OAAO,OAAO,EAAe,GACrC,EAAM,EAAQ,EAAO,EAErB,EAAa,EACb,CACI,GAAG,GACF,GAAM,CAAC,GAAI,EAAQ,IAAQ,GAAK,GAAI,EAAQ,GAAK,CAAC,KAEvD,EAEN,OAAO,EAAS,EAAK,KAAK,KAAM,EAAY,IAGhD,OAAO,EAAS,EAAW,KCpS/B,eAAe,EAAQ,EAAK,CACxB,GAAM,CAAE,MAAM,6BAA8B,UAAW,EAAI,IAAI,QACzD,EAAQ,EAAI,IAAI,MAAM,SAAW,OAAO,SAAS,EAAI,IAAI,MAAM,SAAU,IAAM,GAErF,GAAI,CAAC,EAAO,QAAQ,gCAChB,MAAM,IAAII,EAAoB,mFAGlC,GAAI,CAAC,iCAAiC,KAAK,GACvC,MAAU,MAAM,eAGpB,IAAM,EAAM,EAAO,UAAU,OACvB,EAAU,EAEV,EAAU,EAAe,GACzB,EAAkB,MAAM,EAAoB,EAAS,GAErD,EAAe,EAAuB,EAAS,OAAQ,IACvD,EAAkB,EAAuB,EAAiB,KAAM,IAEtE,EAAgB,OAAO,SAAU,QACjC,EAAgB,OAAO,WAAY,OAAO,IAE1C,IAAM,EAAS,EAAQ,GAAG,EAAQ,QAAS,EAAS,GAC9C,EAAa,EAAQ,EAAsB,IAAoB,GAAI,EAAS,GAElF,GAAI,CACA,GAAM,CAAE,KAAM,GAAa,MAAMC,EAAI,GAE/B,GAAS,MAAM,QAAQ,GAAY,EAAW,KAAK,MAAM,EAAS,MAAM,YAAY,KAAK,MAAM,EAAG,GAAO,IAAK,GAAS,CACzH,IAAM,EAAgB,EAAK,UAAU,WAC/B,EAAO,EAAK,MAAM,UAAY,EAAK,KAEnC,EAAK,EAAK,EAAK,SAAS,UAAY,EAAK,SAE/C,EAAG,OAAO,MAAM,EAAG,IAAO,CACtB,EAAK,EAAG,GAER,IAAM,EAAM,EAAG,KAAK,OAEhB,EAAI,WAAW,KACf,EAAG,KAAK,MAAO,GAAG,IAAM,EAAK,OAAO,KAC7B,EAAI,WAAW,UACtB,EAAG,KAAK,MAAO,GAAG,IAAM,OAIhC,IAAM,EAAc,EAAG,OAEvB,MAAO,CACH,MAAO,EAAK,OAAO,UAAY,EAAK,MACpC,cACA,QAAS,EAAU,EAAK,UACxB,KAAM,EAAK,KACX,SAAU,CAAC,GAAG,IAAI,IAAI,EAAc,OAAO,IAAK,GAAM,EAAE,QACxD,OAAQ,EAAK,UAAU,OAAO,IAAK,GAAM,EAAE,MAAM,KAAK,KACtD,OACA,GAAI,EACJ,QAAS,CACL,KAAM,EACN,KAAM,EAAG,QAEb,QAAS,EAAU,EAAK,iBAI1B,EAAO,MAAM,EAAU,EAAY,GAEzC,MAAO,CACH,GAAG,EACH,KAAM,QAEN,CACJ,IAAM,EAAO,MAAMC,EAAO,SAAS,GAAG,EAAQ,SAExC,EAAQ,EAAK,MAAM,IAAK,GAAS,CACnC,IAAM,EAAO,EAAK,KAEZ,EAAK,EAAK,EAAK,oBAErB,EAAG,OAAO,MAAM,EAAG,IAAO,CACtB,EAAK,EAAG,GAER,IAAM,EAAM,EAAG,KAAK,OAEhB,EAAI,WAAW,KACf,EAAG,KAAK,MAAO,GAAG,IAAM,EAAK,OAAO,KAC7B,EAAI,WAAW,UACtB,EAAG,KAAK,MAAO,GAAG,IAAM,OAIhC,IAAM,EAAc,EAAG,OAEvB,MAAO,CACH,MAAO,EAAK,MACZ,cACA,QAAS,EAAU,EAAK,SAAW,IACnC,KAAM,EAAK,KACX,SAAU,EAAK,WACf,OAAQ,EAAK,QACb,OACA,GAAI,EACJ,QAAS,CACL,KAAM,EACN,KAAM,EAAG,WAKrB,MAAO,CACH,MAAO,EAAK,MACZ,YAAa,EAAK,YAClB,KAAM,EAAK,KACX,KAAM,EACN,WAAY,GACZ,MAAO,EAAK,OAAO,IACnB,SAAU,EAAK,WAK3B,MAAaC,EAAe,CACxB,KAAM,sBACN,KAAM,YACN,IAAK,gBACL,YAAa,CAAC,WACd,UACA,QAAS,iEACT,WAAY,CAAE,IAAK,+CAAgD,OAAQ,qBAC3E,YAAa,moDAWb,WAAY,CAAC,QAEb,SAAU,CACN,cAAe,CACX,CACI,KAAM,kCACN,YAAa,kFACb,SAAU,KAGlB,iBAAkB,GAClB,YAAa,GACb,aAAc,GACd,UAAW,GACX,eAAgB,GAChB,cAAe,IAEnB,MAAO"}