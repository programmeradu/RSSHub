{"version":3,"file":"utils-VPsgV-F2.js","names":["got","got","images: string[]"],"sources":["../../lib/routes/pixiv/pixiv-got.ts","../../lib/routes/pixiv/constants.ts","../../lib/routes/pixiv/token.ts","../../lib/routes/pixiv/utils.ts"],"sourcesContent":["import tls from 'node:tls';\r\nimport ipRegex from 'ip-regex';\r\nimport got from '@/utils/got';\r\nimport logger from '@/utils/logger';\r\nimport { config } from '@/config';\r\n\r\nasync function dohResolve(name, jsonDohEndpoint) {\r\n    try {\r\n        const response = await got(jsonDohEndpoint, {\r\n            searchParams: {\r\n                name,\r\n                type: 'A',\r\n            },\r\n            headers: {\r\n                accept: 'application/dns-json',\r\n            },\r\n        });\r\n        if (response.data.Status === 0) {\r\n            return response.data.Answer.map((item) => item.data);\r\n        } else {\r\n            logger.error(`Error ${response.data.Status} when querying DoH endpoint ${jsonDohEndpoint}`);\r\n        }\r\n    } catch (error) {\r\n        logger.error(`Failed to resolve ${name}`);\r\n        logger.debug(error);\r\n    }\r\n    return [];\r\n}\r\n\r\nconst pixivGot = got.extend({\r\n    hooks: {\r\n        beforeRequest: [\r\n            async (options) => {\r\n                if (!config.pixiv.bypassCdn) {\r\n                    return;\r\n                }\r\n                let hostname = null;\r\n                const isIP = ipRegex({ exact: true }).test(config.pixiv.bypassCdnHostname);\r\n                if (isIP) {\r\n                    hostname = config.pixiv.bypassCdnHostname;\r\n                } else {\r\n                    const addresses = await dohResolve(config.pixiv.bypassCdnHostname, config.pixiv.bypassCdnDoh);\r\n                    if (addresses.length) {\r\n                        hostname = addresses[Math.floor(addresses.length * Math.random())];\r\n                    } else {\r\n                        logger.warn(`No IPv4 address resolved from ${config.pixiv.bypassCdnHostname}`);\r\n                    }\r\n                }\r\n                if (hostname) {\r\n                    const actualHost = options.url.host;\r\n                    options.headers = {\r\n                        ...options.headers,\r\n                        host: actualHost,\r\n                    };\r\n                    options.url.hostname = hostname;\r\n                    options.checkServerIdentity = function (host, certificate) {\r\n                        return tls.checkServerIdentity(actualHost, certificate);\r\n                    };\r\n                }\r\n            },\r\n        ],\r\n    },\r\n});\r\n\r\nexport default pixivGot;\r\n","const maskHeader = {\r\n    'App-OS': 'ios',\r\n    'App-OS-Version': '10.3.1',\r\n    'App-Version': '6.7.1',\r\n    'User-Agent': 'PixivIOSApp/6.7.1 (iOS 10.3.1; iPhone8,1)',\r\n};\r\n\r\nexport { maskHeader };\r\n","import { config } from '@/config';\r\nimport logger from '@/utils/logger';\r\nimport got from './pixiv-got';\r\nimport { maskHeader } from './constants';\r\n\r\nlet token = null;\r\n\r\nconst authorizationInfo = {\r\n    client_id: 'MOBrBDS8blbauoSck0ZfDbtuzpyT',\r\n    client_secret: 'lsACyCD94FhDUtGTXi3QzcFE2uU1hqtDaKeqrdwj',\r\n    hash_secret: '28c1fdd170a5204386cb1313c7077b34f83e4aaf4aa829ce78c231e05b0bae2c',\r\n};\r\n\r\nconst refreshToken = (tryGet) =>\r\n    tryGet(\r\n        'pixiv:accessToken',\r\n        () =>\r\n            got.post('https://oauth.secure.pixiv.net/auth/token', {\r\n                form: {\r\n                    ...authorizationInfo,\r\n                    get_secure_url: 1,\r\n                    grant_type: 'refresh_token',\r\n                    refresh_token: config.pixiv.refreshToken,\r\n                },\r\n                headers: {\r\n                    ...maskHeader,\r\n                },\r\n            }),\r\n        3600,\r\n        false\r\n    );\r\n\r\nasync function getToken(tryGet) {\r\n    const { data } = await refreshToken(tryGet);\r\n    // let expireTime;\r\n    if (data && data.access_token) {\r\n        logger.debug('Pixiv refresh token success.');\r\n        token = data.access_token;\r\n        // expireTime = result.expires_in;\r\n    }\r\n    // } else {\r\n    // expireTime = 30;\r\n    // logger.error(`Pixiv refresh token failed, retry in ${expireTime} seconds.`);\r\n    // }\r\n    // If is package, the mock server should be closed after request, needn't to refresh\r\n    // if (!config.isPackage) {\r\n    //     setTimeout(tickToken, expireTime * 1000);\r\n    // }\r\n    return token;\r\n}\r\n\r\nexport { getToken };\r\n\r\n// let tickTokenStarted = false;\r\n\r\n// async function startTickToken(tryGet) {\r\n//     if (!tickTokenStarted) {\r\n//         // 如果tickToken没启动\r\n//         tickTokenStarted = true;\r\n//         await tickToken(tryGet); // 启动tickToken\r\n//     }\r\n// }\r\n\r\n// async function waitForToken() {\r\n//     while (!token) {\r\n//         // eslint-disable-next-line no-await-in-loop\r\n//         await new Promise((resolve) => setTimeout(resolve, 0));\r\n//     }\r\n//     return token;\r\n// }\r\n\r\n// export default async (tryGet) => {\r\n//     await startTickToken(tryGet);\r\n//     return waitForToken();\r\n// };\r\n\r\n// module.exports.tickToken = tickToken;\r\n","import { config } from '@/config';\r\n\r\nexport default {\r\n    getImgs(illust) {\r\n        const images: string[] = [];\r\n        if (illust.meta_pages?.length) {\r\n            for (const page of illust.meta_pages) {\r\n                const original = page.image_urls.original.replace('https://i.pximg.net', config.pixiv.imgProxy);\r\n                images.push(`<p><img src=\"${original}\" width=\"${page.width}\" height=\"${page.height}\" /></p>`);\r\n            }\r\n        } else if (illust.meta_single_page.original_image_url) {\r\n            const original = illust.meta_single_page.original_image_url.replace('https://i.pximg.net', config.pixiv.imgProxy);\r\n            images.push(`<p><img src=\"${original}\" width=\"${illust.width}\" height=\"${illust.height}\" /></p>`);\r\n        }\r\n        return images;\r\n    },\r\n    getProxiedImageUrl(originalUrl: string): string {\r\n        return originalUrl.replace('https://i.pximg.net', config.pixiv.imgProxy || '');\r\n    },\r\n};\r\n"],"mappings":"oMAMA,eAAe,EAAW,EAAM,EAAiB,CAC7C,GAAI,CACA,IAAM,EAAW,MAAMC,EAAI,EAAiB,CACxC,aAAc,CACV,OACA,KAAM,KAEV,QAAS,CACL,OAAQ,0BAGhB,GAAI,EAAS,KAAK,SAAW,EACzB,OAAO,EAAS,KAAK,OAAO,IAAK,GAAS,EAAK,MAE/C,EAAO,MAAM,SAAS,EAAS,KAAK,OAAO,8BAA8B,WAExE,EAAO,CACZ,EAAO,MAAM,qBAAqB,KAClC,EAAO,MAAM,GAEjB,MAAO,GAGX,MAAM,EAAWA,EAAI,OAAO,CACxB,MAAO,CACH,cAAe,CACX,KAAO,IAAY,CACf,GAAI,CAAC,EAAO,MAAM,UACd,OAEJ,IAAI,EAAW,KACT,EAAO,EAAQ,CAAE,MAAO,KAAQ,KAAK,EAAO,MAAM,mBACxD,GAAI,EACA,EAAW,EAAO,MAAM,sBACrB,CACH,IAAM,EAAY,MAAM,EAAW,EAAO,MAAM,kBAAmB,EAAO,MAAM,cAC5E,EAAU,OACV,EAAW,EAAU,KAAK,MAAM,EAAU,OAAS,KAAK,WAExD,EAAO,KAAK,iCAAiC,EAAO,MAAM,qBAGlE,GAAI,EAAU,CACV,IAAM,EAAa,EAAQ,IAAI,KAC/B,EAAQ,QAAU,CACd,GAAG,EAAQ,QACX,KAAM,GAEV,EAAQ,IAAI,SAAW,EACvB,EAAQ,oBAAsB,SAAU,EAAM,EAAa,CACvD,OAAO,EAAI,oBAAoB,EAAY,UAQnE,IAAA,EAAe,EChEf,MAAM,EAAa,CACf,SAAU,MACV,iBAAkB,SAClB,cAAe,QACf,aAAc,6CCClB,IAAI,EAAQ,KAEZ,MAAM,EAAoB,CACtB,UAAW,+BACX,cAAe,2CACf,YAAa,oEAGX,EAAgB,GAClB,EACI,wBAEIA,EAAI,KAAK,4CAA6C,CAClD,KAAM,CACF,GAAG,EACH,eAAgB,EAChB,WAAY,gBACZ,cAAe,EAAO,MAAM,cAEhC,QAAS,CACL,GAAG,KAGf,KACA,IAGR,eAAe,EAAS,EAAQ,CAC5B,GAAM,CAAE,QAAS,MAAM,EAAa,GAepC,OAbI,GAAQ,EAAK,eACb,EAAO,MAAM,gCACb,EAAQ,EAAK,cAWV,EC9CX,IAAA,EAAe,CACX,QAAQ,EAAQ,CACZ,IAAMC,EAAmB,GACzB,GAAI,EAAO,YAAY,OACnB,IAAK,IAAM,KAAQ,EAAO,WAAY,CAClC,IAAM,EAAW,EAAK,WAAW,SAAS,QAAQ,sBAAuB,EAAO,MAAM,UACtF,EAAO,KAAK,gBAAgB,EAAS,WAAW,EAAK,MAAM,YAAY,EAAK,OAAO,mBAEhF,EAAO,iBAAiB,mBAAoB,CACnD,IAAM,EAAW,EAAO,iBAAiB,mBAAmB,QAAQ,sBAAuB,EAAO,MAAM,UACxG,EAAO,KAAK,gBAAgB,EAAS,WAAW,EAAO,MAAM,YAAY,EAAO,OAAO,WAE3F,OAAO,GAEX,mBAAmB,EAA6B,CAC5C,OAAO,EAAY,QAAQ,sBAAuB,EAAO,MAAM,UAAY"}