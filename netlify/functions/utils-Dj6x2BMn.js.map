{"version":3,"file":"utils-Dj6x2BMn.js","names":["index","cache","ofetch","playlistId","utils","NotFoundError"],"sources":["../../lib/routes/youtube/api/google.ts","../../lib/routes/youtube/utils.ts"],"sourcesContent":["import { google } from 'googleapis';\r\nconst { OAuth2 } = google.auth;\r\nimport { config } from '@/config';\r\nimport utils, { getVideoUrl } from '../utils';\r\nimport cache from '@/utils/cache';\r\nimport { parseDate } from '@/utils/parse-date';\r\nimport ofetch from '@/utils/ofetch';\r\nimport * as cheerio from 'cheerio';\r\nimport NotFoundError from '@/errors/types/not-found';\r\nimport { Data } from '@/types';\r\nimport dayjs from 'dayjs';\r\nimport duration from 'dayjs/plugin/duration.js';\r\ndayjs.extend(duration);\r\n\r\nlet count = 0;\r\nconst youtube = {};\r\nif (config.youtube && config.youtube.key) {\r\n    const keys = config.youtube.key.split(',');\r\n\r\n    for (const [index, key] of keys.entries()) {\r\n        if (key) {\r\n            youtube[index] = google.youtube({\r\n                version: 'v3',\r\n                auth: key,\r\n            });\r\n            count = index + 1;\r\n        }\r\n    }\r\n}\r\n\r\nlet index = -1;\r\nconst exec = async (func) => {\r\n    let result;\r\n    for (let i = 0; i < count; i++) {\r\n        index++;\r\n        try {\r\n            // eslint-disable-next-line no-await-in-loop\r\n            result = await func(youtube[index % count]);\r\n            break;\r\n        } catch {\r\n            // console.error(error);\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nlet youtubeOAuth2Client;\r\nif (config.youtube && config.youtube.clientId && config.youtube.clientSecret && config.youtube.refreshToken) {\r\n    youtubeOAuth2Client = new OAuth2(config.youtube.clientId, config.youtube.clientSecret, 'https://developers.google.com/oauthplayground');\r\n    youtubeOAuth2Client.setCredentials({ refresh_token: config.youtube.refreshToken });\r\n}\r\n\r\nexport { youtubeOAuth2Client, exec };\r\n\r\nexport const getDataByUsername = async ({ username, embed, filterShorts }: { username: string; embed: boolean; filterShorts: boolean }): Promise<Data> => {\r\n    let userHandleData;\r\n    if (username.startsWith('@')) {\r\n        userHandleData = await cache.tryGet(`youtube:handle:${username}`, async () => {\r\n            const link = `https://www.youtube.com/${username}`;\r\n            const response = await ofetch(link);\r\n            const $ = cheerio.load(response);\r\n            const ytInitialData = JSON.parse(\r\n                $('script')\r\n                    .text()\r\n                    .match(/ytInitialData = ({.*?});/)?.[1] || '{}'\r\n            );\r\n            const metadataRenderer = ytInitialData.metadata.channelMetadataRenderer;\r\n\r\n            const channelId = metadataRenderer.externalId;\r\n            const channelName = metadataRenderer.title;\r\n            const image = metadataRenderer.avatar?.thumbnails?.[0]?.url;\r\n            const description = metadataRenderer.description;\r\n            const playlistId = (await utils.getChannelWithId(channelId, 'contentDetails', cache)).data.items[0].contentDetails.relatedPlaylists.uploads;\r\n\r\n            return {\r\n                channelName,\r\n                image,\r\n                description,\r\n                playlistId,\r\n            };\r\n        });\r\n    }\r\n\r\n    // Get the appropriate playlist ID based on filterShorts setting\r\n    const playlistId = await (async () => {\r\n        if (userHandleData?.playlistId) {\r\n            const origPlaylistId = userHandleData.playlistId;\r\n\r\n            return utils.getPlaylistWithShortsFilter(origPlaylistId, filterShorts);\r\n        } else {\r\n            const channelData = await utils.getChannelWithUsername(username, 'contentDetails', cache);\r\n            const items = channelData.data.items;\r\n\r\n            if (!items) {\r\n                throw new NotFoundError(`The channel https://www.youtube.com/user/${username} does not exist.`);\r\n            }\r\n\r\n            const channelId = items[0].id;\r\n\r\n            return filterShorts ? utils.getPlaylistWithShortsFilter(channelId, filterShorts) : items[0].contentDetails.relatedPlaylists.uploads;\r\n        }\r\n    })();\r\n\r\n    const playlistItems = await utils.getPlaylistItems(playlistId, 'snippet', cache);\r\n    if (!playlistItems) {\r\n        throw new NotFoundError(\"This channel doesn't have any content.\");\r\n    }\r\n    const videoIds = playlistItems.data.items.map((item) => item.snippet.resourceId.videoId).join(',');\r\n    const videoDetails = await utils.getVideos(videoIds, 'contentDetails', cache);\r\n\r\n    return {\r\n        title: `${userHandleData?.channelName || username} - YouTube`,\r\n        link: username.startsWith('@') ? `https://www.youtube.com/${username}` : `https://www.youtube.com/user/${username}`,\r\n        description: userHandleData?.description || `YouTube user ${username}`,\r\n        image: userHandleData?.image,\r\n        item: playlistItems.data.items\r\n            .filter((d) => d.snippet.title !== 'Private video' && d.snippet.title !== 'Deleted video')\r\n            .map((item) => {\r\n                const snippet = item.snippet;\r\n                const videoId = snippet.resourceId.videoId;\r\n                const img = utils.getThumbnail(snippet.thumbnails);\r\n                const detail = videoDetails?.data.items.find((d) => d.id === videoId);\r\n                return {\r\n                    title: snippet.title,\r\n                    description: utils.renderDescription(embed, videoId, img, utils.formatDescription(snippet.description)),\r\n                    pubDate: parseDate(snippet.publishedAt),\r\n                    link: `https://www.youtube.com/watch?v=${videoId}`,\r\n                    author: snippet.videoOwnerChannelTitle,\r\n                    image: img.url,\r\n                    attachments: [\r\n                        {\r\n                            url: getVideoUrl(videoId),\r\n                            mime_type: 'text/html',\r\n                            duration_in_seconds: detail?.contentDetails.duration ? dayjs.duration(detail.contentDetails.duration).asSeconds() : undefined,\r\n                        },\r\n                    ],\r\n                };\r\n            }),\r\n    };\r\n};\r\n\r\nexport const getDataByChannelId = async ({ channelId, embed, filterShorts }: { channelId: string; embed: boolean; filterShorts: boolean }): Promise<Data> => {\r\n    // Get original uploads playlist ID if needed\r\n    const originalPlaylistId = filterShorts ? null : (await utils.getChannelWithId(channelId, 'contentDetails', cache)).data.items[0].contentDetails.relatedPlaylists.uploads;\r\n\r\n    // Use the utility function to get the appropriate playlist ID based on filterShorts setting\r\n    const playlistId = filterShorts ? utils.getPlaylistWithShortsFilter(channelId) : originalPlaylistId;\r\n\r\n    const data = (await utils.getPlaylistItems(playlistId, 'snippet', cache)).data.items;\r\n    const videoIds = data.map((item) => item.snippet.resourceId.videoId).join(',');\r\n    const videoDetails = await utils.getVideos(videoIds, 'contentDetails', cache);\r\n\r\n    return {\r\n        title: `${data[0].snippet.channelTitle} - YouTube`,\r\n        link: `https://www.youtube.com/channel/${channelId}`,\r\n        description: `YouTube channel ${data[0].snippet.channelTitle}`,\r\n        item: data\r\n            .filter((d) => d.snippet.title !== 'Private video' && d.snippet.title !== 'Deleted video')\r\n            .map((item) => {\r\n                const snippet = item.snippet;\r\n                const videoId = snippet.resourceId.videoId;\r\n                const img = utils.getThumbnail(snippet.thumbnails);\r\n                const detail = videoDetails?.data.items.find((d) => d.id === videoId);\r\n                return {\r\n                    title: snippet.title,\r\n                    description: utils.renderDescription(embed, videoId, img, utils.formatDescription(snippet.description)),\r\n                    pubDate: parseDate(snippet.publishedAt),\r\n                    link: `https://www.youtube.com/watch?v=${videoId}`,\r\n                    author: snippet.videoOwnerChannelTitle,\r\n                    image: img.url,\r\n                    attachments: [\r\n                        {\r\n                            url: getVideoUrl(videoId),\r\n                            mime_type: 'text/html',\r\n                            duration_in_seconds: detail?.contentDetails.duration ? dayjs.duration(detail.contentDetails.duration).asSeconds() : undefined,\r\n                        },\r\n                    ],\r\n                };\r\n            }),\r\n    };\r\n};\r\n\r\nexport const getDataByPlaylistId = async ({ playlistId, embed }: { playlistId: string; embed: boolean }): Promise<Data> => {\r\n    const playlistTitle = (await utils.getPlaylist(playlistId, 'snippet', cache)).data.items[0].snippet.title;\r\n\r\n    const data = (await utils.getPlaylistItems(playlistId, 'snippet', cache)).data.items.filter((d) => d.snippet.title !== 'Private video' && d.snippet.title !== 'Deleted video');\r\n    const videoIds = data.map((item) => item.snippet.resourceId.videoId).join(',');\r\n    const videoDetails = await utils.getVideos(videoIds, 'contentDetails', cache);\r\n\r\n    return {\r\n        title: `${playlistTitle} by ${data[0].snippet.channelTitle} - YouTube`,\r\n        link: `https://www.youtube.com/playlist?list=${playlistId}`,\r\n        description: `${playlistTitle} by ${data[0].snippet.channelTitle}`,\r\n        item: data.map((item) => {\r\n            const snippet = item.snippet;\r\n            const videoId = snippet.resourceId.videoId;\r\n            const img = utils.getThumbnail(snippet.thumbnails);\r\n            const detail = videoDetails?.data.items.find((d) => d.id === videoId);\r\n            return {\r\n                title: snippet.title,\r\n                description: utils.renderDescription(embed, videoId, img, utils.formatDescription(snippet.description)),\r\n                pubDate: parseDate(snippet.publishedAt),\r\n                link: `https://www.youtube.com/watch?v=${videoId}`,\r\n                author: snippet.videoOwnerChannelTitle,\r\n                image: img.url,\r\n                attachments: [\r\n                    {\r\n                        url: getVideoUrl(videoId),\r\n                        mime_type: 'text/html',\r\n                        duration_in_seconds: detail?.contentDetails.duration ? dayjs.duration(detail.contentDetails.duration).asSeconds() : undefined,\r\n                    },\r\n                ],\r\n            };\r\n        }),\r\n    };\r\n};\r\n","import { google } from 'googleapis';\r\nimport { art } from '@/utils/render';\r\nimport path from 'node:path';\r\nimport { config } from '@/config';\r\nimport { youtubeOAuth2Client, exec } from './api/google';\r\n\r\nexport const getPlaylistItems = (id, part, cache) =>\r\n    cache.tryGet(\r\n        `youtube:getPlaylistItems:${id}`,\r\n        async () => {\r\n            const res = await exec((youtube) =>\r\n                youtube.playlistItems.list({\r\n                    part,\r\n                    playlistId: id,\r\n                    maxResults: 50, // youtube api param value default is 5\r\n                })\r\n            );\r\n            return res;\r\n        },\r\n        config.cache.routeExpire,\r\n        false\r\n    );\r\nexport const getPlaylist = (id, part, cache) =>\r\n    cache.tryGet(`youtube:getPlaylist:${id}`, async () => {\r\n        const res = await exec((youtube) =>\r\n            youtube.playlists.list({\r\n                part,\r\n                id,\r\n            })\r\n        );\r\n        return res;\r\n    });\r\nexport const getChannelWithId = (id, part, cache) =>\r\n    cache.tryGet(`youtube:getChannelWithId:${id}`, async () => {\r\n        const res = await exec((youtube) =>\r\n            youtube.channels.list({\r\n                part,\r\n                id,\r\n            })\r\n        );\r\n        return res;\r\n    });\r\nexport const getChannelWithUsername = (username, part, cache) =>\r\n    cache.tryGet(`youtube:getChannelWithUsername:${username}`, async () => {\r\n        const res = await exec((youtube) =>\r\n            youtube.channels.list({\r\n                part,\r\n                forUsername: username,\r\n            })\r\n        );\r\n        return res;\r\n    });\r\nexport const getVideos = (id, part, cache) =>\r\n    cache.tryGet(`youtube:getVideos:${id}`, async () => {\r\n        const res = await exec((youtube) =>\r\n            youtube.videos.list({\r\n                part,\r\n                id,\r\n            })\r\n        );\r\n        return res;\r\n    });\r\nexport const getThumbnail = (thumbnails) => thumbnails.maxres || thumbnails.standard || thumbnails.high || thumbnails.medium || thumbnails.default;\r\nexport const formatDescription = (description) => description?.replaceAll(/\\r\\n|\\r|\\n/g, '<br>');\r\nexport const renderDescription = (embed, videoId, img, description) =>\r\n    art(path.join(__dirname, 'templates/description.art'), {\r\n        embed,\r\n        videoId,\r\n        img,\r\n        description,\r\n    });\r\n\r\nexport const getSubscriptions = async (part, cache) => {\r\n    // access tokens expire after one hour\r\n    let accessToken = await cache.get('youtube:accessToken', false);\r\n    if (!accessToken) {\r\n        const data = await youtubeOAuth2Client.getAccessToken();\r\n        accessToken = data.token;\r\n        await cache.set('youtube:accessToken', accessToken, 3600); // ~3600s\r\n    }\r\n    youtubeOAuth2Client.setCredentials({ access_token: accessToken, refresh_token: config.youtube.refreshToken });\r\n\r\n    return cache.tryGet('youtube:getSubscriptions', () => getSubscriptionsRecusive(part), config.cache.routeExpire, false);\r\n};\r\nexport async function getSubscriptionsRecusive(part, nextPageToken?) {\r\n    const res = await google.youtube('v3').subscriptions.list({\r\n        auth: youtubeOAuth2Client,\r\n        part,\r\n        mine: true,\r\n        maxResults: 50,\r\n        pageToken: nextPageToken ?? undefined,\r\n    });\r\n    // recursively get next page\r\n    if (res.data.nextPageToken) {\r\n        const next = await getSubscriptionsRecusive(part, res.data.nextPageToken);\r\n        if (next.data.items) {\r\n            res.data.items = [...(res.data.items || []), ...next.data.items];\r\n        }\r\n    }\r\n    return res;\r\n}\r\n// taken from https://webapps.stackexchange.com/a/101153\r\nexport const isYouTubeChannelId = (id) => /^UC[\\w-]{21}[AQgw]$/.test(id);\r\nexport const getLive = (id, cache) =>\r\n    cache.tryGet(`youtube:getLive:${id}`, async () => {\r\n        const res = await exec((youtube) =>\r\n            youtube.search.list({\r\n                part: 'snippet',\r\n                channelId: id,\r\n                eventType: 'live',\r\n                type: 'video',\r\n            })\r\n        );\r\n        return res;\r\n    });\r\nexport const getVideoUrl = (id: string) => `https://www.youtube-nocookie.com/embed/${id}?controls=1&autoplay=1&mute=0`;\r\n\r\n// Get the appropriate playlist ID with or without shorts\r\nexport const getPlaylistWithShortsFilter = (id: string, filterShorts = true): string => {\r\n    // If filtering shorts is enabled\r\n    if (filterShorts) {\r\n        if (id.startsWith('UC')) {\r\n            // For channel IDs (UC...), convert to playlist format without shorts (UULF...)\r\n            return 'UULF' + id.slice(2);\r\n        } else if (id.startsWith('UU')) {\r\n            // For playlist IDs (UU...), convert to playlist format without shorts (UULF...)\r\n            return 'UULF' + id.slice(2);\r\n        }\r\n    }\r\n    // If filterShorts is false or the ID format doesn't match known patterns, return original ID\r\n    return id;\r\n};\r\n\r\nexport const callApi = async <T>({ googleApi, youtubeiApi, params }: { googleApi: (params: any) => Promise<T>; youtubeiApi: (params: any) => Promise<T>; params: any }): Promise<T> => {\r\n    if (config.youtube?.key) {\r\n        try {\r\n            return await googleApi(params);\r\n        } catch {\r\n            return await youtubeiApi(params);\r\n        }\r\n    }\r\n    return await youtubeiApi(params);\r\n};\r\n\r\nexport default {\r\n    getPlaylistItems,\r\n    getPlaylist,\r\n    getChannelWithId,\r\n    getChannelWithUsername,\r\n    getVideos,\r\n    getThumbnail,\r\n    formatDescription,\r\n    renderDescription,\r\n    getSubscriptions,\r\n    getSubscriptionsRecusive,\r\n    isYouTubeChannelId,\r\n    getLive,\r\n    getVideoUrl,\r\n    getPlaylistWithShortsFilter,\r\n};\r\n"],"mappings":"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"}