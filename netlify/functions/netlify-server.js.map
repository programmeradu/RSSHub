{"version":3,"file":"netlify-server.js","names":["wrappedFetch: typeof undici.fetch","options: RequestInit","proxy","getWrappedGet: <T extends Get>(origin: T) => T","url: URL | null","options: http.RequestOptions","callback: ((res: http.IncomingMessage) => void) | undefined","proxy","fetch","getWrappedGet"],"sources":["../../lib/utils/request-rewriter/fetch.ts","../../lib/utils/request-rewriter/get.ts","../../lib/utils/request-rewriter/index.ts","../../lib/netlify-server.ts"],"sourcesContent":["import logger from '@/utils/logger';\r\nimport { config } from '@/config';\r\nimport undici, { Request, RequestInfo, RequestInit } from 'undici';\r\nimport proxy from '@/utils/proxy';\r\nimport { RateLimiterMemory, RateLimiterQueue } from 'rate-limiter-flexible';\r\nimport { useRegisterRequest } from 'node-network-devtools';\r\n\r\nconst limiter = new RateLimiterMemory({\r\n    points: 10,\r\n    duration: 1,\r\n    execEvenly: true,\r\n});\r\n\r\nconst limiterQueue = new RateLimiterQueue(limiter, {\r\n    maxQueueSize: 4800,\r\n});\r\n\r\nexport const useCustomHeader = (headers: Headers) => {\r\n    process.env.NODE_ENV === 'dev' &&\r\n        useRegisterRequest((req) => {\r\n            for (const [key, value] of headers.entries()) {\r\n                req.requestHeaders[key] = value;\r\n            }\r\n            return req;\r\n        });\r\n};\r\n\r\nconst wrappedFetch: typeof undici.fetch = async (input: RequestInfo, init?: RequestInit) => {\r\n    const request = new Request(input, init);\r\n    const options: RequestInit = {};\r\n\r\n    logger.debug(`Outgoing request: ${request.method} ${request.url}`);\r\n\r\n    // ua\r\n    if (!request.headers.get('user-agent')) {\r\n        request.headers.set('user-agent', config.ua);\r\n    }\r\n\r\n    // accept\r\n    if (!request.headers.get('accept')) {\r\n        request.headers.set('accept', '*/*');\r\n    }\r\n\r\n    // referer\r\n    if (!request.headers.get('referer')) {\r\n        try {\r\n            const urlHandler = new URL(request.url);\r\n            request.headers.set('referer', urlHandler.origin);\r\n        } catch {\r\n            // ignore\r\n        }\r\n    }\r\n\r\n    let isRetry = false;\r\n    if (request.headers.get('x-prefer-proxy')) {\r\n        isRetry = true;\r\n        request.headers.delete('x-prefer-proxy');\r\n    }\r\n\r\n    config.enableRemoteDebugging && useCustomHeader(request.headers);\r\n\r\n    // proxy\r\n    if (!init?.dispatcher && (proxy.proxyObj.strategy !== 'on_retry' || isRetry)) {\r\n        const proxyRegex = new RegExp(proxy.proxyObj.url_regex);\r\n        let urlHandler;\r\n        try {\r\n            urlHandler = new URL(request.url);\r\n        } catch {\r\n            // ignore\r\n        }\r\n\r\n        if (proxyRegex.test(request.url) && request.url.startsWith('http') && !(urlHandler && urlHandler.host === proxy.proxyUrlHandler?.host)) {\r\n            const currentProxy = proxy.getCurrentProxy();\r\n            if (currentProxy) {\r\n                const dispatcher = proxy.getDispatcherForProxy(currentProxy);\r\n                if (dispatcher) {\r\n                    options.dispatcher = dispatcher;\r\n                    logger.debug(`Proxying request via ${currentProxy.uri}: ${request.url}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    await limiterQueue.removeTokens(1);\r\n\r\n    const maxRetries = proxy.multiProxy?.allProxies.length || 1;\r\n\r\n    const attemptRequest = async (attempt: number): Promise<Response> => {\r\n        try {\r\n            return await undici.fetch(request, options);\r\n        } catch (error) {\r\n            if (options.dispatcher && proxy.multiProxy && attempt < maxRetries - 1) {\r\n                const currentProxy = proxy.getCurrentProxy();\r\n                if (currentProxy) {\r\n                    logger.warn(`Request failed with proxy ${currentProxy.uri}, trying next proxy: ${error}`);\r\n                    proxy.markProxyFailed(currentProxy.uri);\r\n\r\n                    const nextProxy = proxy.getCurrentProxy();\r\n                    if (nextProxy && nextProxy.uri !== currentProxy.uri) {\r\n                        const nextDispatcher = proxy.getDispatcherForProxy(nextProxy);\r\n                        if (nextDispatcher) {\r\n                            options.dispatcher = nextDispatcher;\r\n                        }\r\n                        logger.debug(`Retrying request with proxy ${nextProxy.uri}: ${request.url}`);\r\n                        return attemptRequest(attempt + 1);\r\n                    } else {\r\n                        logger.warn('No more proxies available, trying without proxy');\r\n                        delete options.dispatcher;\r\n                        return attemptRequest(attempt + 1);\r\n                    }\r\n                }\r\n            }\r\n            throw error;\r\n        }\r\n    };\r\n\r\n    return attemptRequest(0);\r\n};\r\n\r\nexport default wrappedFetch;\r\n","import http from 'node:http';\r\nimport https from 'node:https';\r\nimport logger from '@/utils/logger';\r\nimport { config } from '@/config';\r\nimport proxy from '@/utils/proxy';\r\n\r\ntype Get = typeof http.get | typeof https.get | typeof http.request | typeof https.request;\r\n\r\nconst getWrappedGet: <T extends Get>(origin: T) => T = (origin) =>\r\n    function (this: any, ...args: Parameters<typeof origin>) {\r\n        let url: URL | null;\r\n        let options: http.RequestOptions = {};\r\n        let callback: ((res: http.IncomingMessage) => void) | undefined;\r\n        if (typeof args[0] === 'string' || args[0] instanceof URL) {\r\n            url = new URL(args[0]);\r\n            if (typeof args[1] === 'object') {\r\n                options = args[1];\r\n                callback = args[2];\r\n            } else if (typeof args[1] === 'function') {\r\n                options = {};\r\n                callback = args[1];\r\n            }\r\n        } else {\r\n            options = args[0];\r\n            try {\r\n                url = new URL(options.href || `${options.protocol || 'http:'}//${options.hostname || options.host}${options.path}${options.search || (options.query ? `?${options.query}` : '')}`);\r\n            } catch {\r\n                url = null;\r\n            }\r\n            if (typeof args[1] === 'function') {\r\n                callback = args[1];\r\n            }\r\n        }\r\n        if (!url) {\r\n            return Reflect.apply(origin, this, args) as ReturnType<typeof origin>;\r\n        }\r\n\r\n        logger.debug(`Outgoing request: ${options.method || 'GET'} ${url}`);\r\n\r\n        options.headers = options.headers || {};\r\n        const headersLowerCaseKeys = new Set(Object.keys(options.headers).map((key) => key.toLowerCase()));\r\n\r\n        // ua\r\n        if (!headersLowerCaseKeys.has('user-agent')) {\r\n            options.headers['user-agent'] = config.ua;\r\n        }\r\n\r\n        // Accept\r\n        if (!headersLowerCaseKeys.has('accept')) {\r\n            options.headers.accept = '*/*';\r\n        }\r\n\r\n        // referer\r\n        if (!headersLowerCaseKeys.has('referer')) {\r\n            options.headers.referer = url.origin;\r\n        }\r\n\r\n        // proxy\r\n        if (!options.agent && proxy.agent) {\r\n            const proxyRegex = new RegExp(proxy.proxyObj.url_regex);\r\n\r\n            if (\r\n                proxyRegex.test(url.toString()) &&\r\n                url.protocol.startsWith('http') &&\r\n                url.host !== proxy.proxyUrlHandler?.host &&\r\n                url.host !== 'localhost' &&\r\n                !url.host.startsWith('127.') &&\r\n                !(config.puppeteerWSEndpoint?.includes(url.host) ?? false)\r\n            ) {\r\n                options.agent = proxy.agent;\r\n            }\r\n        }\r\n\r\n        return Reflect.apply(origin, this, [url, options, callback]) as ReturnType<typeof origin>;\r\n    };\r\n\r\nexport default getWrappedGet;\r\n","import { Headers, FormData, Request, Response } from 'undici';\r\nimport http from 'node:http';\r\nimport https from 'node:https';\r\n\r\nimport fetch from '@/utils/request-rewriter/fetch';\r\nimport getWrappedGet from '@/utils/request-rewriter/get';\r\n\r\nObject.defineProperties(globalThis, {\r\n    fetch: { value: fetch },\r\n    Headers: { value: Headers },\r\n    FormData: { value: FormData },\r\n    Request: { value: Request },\r\n    Response: { value: Response },\r\n});\r\n\r\nhttp.get = getWrappedGet(http.get);\r\nhttp.request = getWrappedGet(http.request);\r\nhttps.get = getWrappedGet(https.get);\r\nhttps.request = getWrappedGet(https.request);\r\n","// This file is for compatibility with Netlify's deployment.\r\n\r\nimport '@/utils/request-rewriter';\r\nimport { config } from '@/config';\r\nimport logger from '@/utils/logger';\r\n\r\n// Handle Netlify-specific initialization and environment setup\r\nconst initializeNetlifyEnvironment = () => {\r\n    // Set Netlify-specific environment variables if not already set\r\n    if (!process.env.NODE_ENV) {\r\n        process.env.NODE_ENV = 'production';\r\n    }\r\n    \r\n    // Configure logging for Netlify environment\r\n    if (process.env.NETLIFY) {\r\n        // Netlify environment detected\r\n        logger.info('Initializing RSSHub for Netlify Functions environment');\r\n        \r\n        // Disable file logging in serverless environment\r\n        process.env.NO_LOGFILES = 'true';\r\n        \r\n        // Set appropriate cache type for serverless\r\n        if (!process.env.CACHE_TYPE) {\r\n            // Default to memory cache in Netlify if Redis is not configured\r\n            process.env.CACHE_TYPE = config.redis.url && config.redis.url !== 'redis://localhost:6379/' ? 'redis' : 'memory';\r\n        }\r\n        \r\n        // Optimize for serverless constraints\r\n        if (!process.env.REQUEST_TIMEOUT) {\r\n            // Set shorter timeout for serverless functions (25 seconds to stay under Netlify's 30s limit)\r\n            process.env.REQUEST_TIMEOUT = '25000';\r\n        }\r\n        \r\n        // Disable clustering in serverless environment\r\n        process.env.ENABLE_CLUSTER = 'false';\r\n        \r\n        // Configure memory limits for Netlify\r\n        if (!process.env.MEMORY_MAX) {\r\n            // Reduce memory cache size for serverless constraints (64 items vs default 256)\r\n            process.env.MEMORY_MAX = '64';\r\n        }\r\n        \r\n        // Optimize for efficient route loading in serverless environment\r\n        // The existing app-bootstrap handles dynamic route imports efficiently\r\n        // by leveraging the registry system which loads routes on-demand\r\n        \r\n        logger.info('Netlify environment configuration applied');\r\n    }\r\n};\r\n\r\n// Initialize Netlify environment\r\ninitializeNetlifyEnvironment();\r\n\r\n// Import and configure the RSSHub app for Netlify function execution\r\nexport default (await import('./app-bootstrap')).default;"],"mappings":"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"}