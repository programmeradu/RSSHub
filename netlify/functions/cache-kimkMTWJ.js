import{config as e}from"./config-Dl8a1sIg.js";import{logger_default as t}from"./logger-CWOoofbD.js";import n from"ioredis";import{LRUCache as r}from"lru-cache";const i={available:!1},a={},o=e=>{if(e.startsWith(`rsshub:cacheTtl:`))throw Error(`"rsshub:cacheTtl:" prefix is reserved for the internal usage, please change your cache key`);return`rsshub:cacheTtl:${e}`};var s={init:()=>{a.redisClient=new n(e.redis.url),a.redisClient.on(`error`,e=>{i.available=!1,t.error(`Redis error: `,e)}),a.redisClient.on(`end`,()=>{i.available=!1}),a.redisClient.on(`connect`,()=>{i.available=!0,t.info(`Redis connected.`)})},get:async(t,n=!0)=>{if(t&&i.available&&a.redisClient){let r=o(t),[i,s]=await a.redisClient.mget(t,r);return i&&n&&(s?a.redisClient.expire(r,s):s=e.cache.contentExpire+``,a.redisClient.expire(t,s),i+=``),i||``}else return null},set:(t,n,r=e.cache.contentExpire)=>{if(!(!i.available||!a.redisClient)&&((!n||n===`undefined`)&&(n=``),typeof n==`object`&&(n=JSON.stringify(n)),t))return r!==e.cache.contentExpire&&a.redisClient.set(o(t),r,`EX`,r),a.redisClient.set(t,n,`EX`,r)},clients:a,status:i};const c={available:!1},l={};var u={init:()=>{l.memoryCache=new r({ttl:e.cache.routeExpire*1e3,max:e.memory.max}),c.available=!0},get:(e,t=!0)=>{if(e&&c.available&&l.memoryCache){let n=l.memoryCache.get(e,{updateAgeOnGet:t});return n&&(n+=``),n}else return null},set:(t,n,r=e.cache.contentExpire)=>{if((!n||n===`undefined`)&&(n=``),typeof n==`object`&&(n=JSON.stringify(n)),t&&c.available&&l.memoryCache)return l.memoryCache.set(t,n,{ttl:r*1e3})},clients:l,status:c};const d={get:()=>null,set:()=>null};let f;if(e.cache.type===`redis`){f=s,f.init();let{redisClient:e}=f.clients;d.get=async t=>{if(t&&f.status.available&&e){let n=await e.get(t);return n}},d.set=f.set}else if(e.cache.type===`memory`){f=u,f.init();let{memoryCache:t}=f.clients;d.get=e=>{if(e&&f.status.available&&t)return t.get(e,{updateAgeOnGet:!1})},d.set=(n,r,i=e.cache.routeExpire)=>{if((!r||r===`undefined`)&&(r=``),typeof r==`object`&&(r=JSON.stringify(r)),n&&t)return t.set(n,r,{ttl:i*1e3})}}else f={init:()=>null,get:()=>null,set:()=>null,status:{available:!1},clients:{}},t.error(`Cache not available, concurrent requests are not limited. This could lead to bad behavior.`);var p={...f,tryGet:async(t,n,r=e.cache.contentExpire,i=!0)=>{if(typeof t!=`string`)throw TypeError(`Cache key must be a string`);let a=await f.get(t,i);if(a){let e;try{e=JSON.parse(a)}catch{e=null}return e&&(a=e),a}else{let e=await n();return f.set(t,e,r),e}},globalCache:d};export{p as cache_default};
//# sourceMappingURL=cache-kimkMTWJ.js.map