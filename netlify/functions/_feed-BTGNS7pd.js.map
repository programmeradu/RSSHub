{"version":3,"file":"_feed-BTGNS7pd.js","names":["ConfigNotFoundError","cache","constants","got","getToken","cache","got","constants","ConfigNotFoundError","queryParts: string[]","cache","got","constants","cover: string | undefined"],"sources":["../../lib/routes/mangadex/_constants.ts","../../lib/routes/mangadex/_access.ts","../../lib/routes/mangadex/_profile.ts","../../lib/routes/mangadex/_utils.ts","../../lib/routes/mangadex/_feed.ts"],"sourcesContent":["/**\r\n * Define constants for the MangaDex.\r\n */\r\nexport default {\r\n    API: {\r\n        /**\r\n         * Base URL for the MangaDex API.\r\n         *\r\n         */\r\n        BASE: 'https://api.mangadex.org',\r\n\r\n        /**\r\n         * Base URL for the fetching the manga details.\r\n         *\r\n         * @usage https://api.mangadex.org/manga/:id\r\n         * @see https://api.mangadex.org/docs/redoc.html#tag/Manga/operation/get-manga-id\r\n         * @usage https://api.mangadex.org/manga/:id/feed\r\n         * @see https://api.mangadex.org/docs/redoc.html#tag/Manga/operation/get-manga-id-feed\r\n         */\r\n        MANGA_META: 'https://api.mangadex.org/manga/',\r\n\r\n        /**\r\n         * Base URL for a specific chapter in MangaDex Reading page.\r\n         *\r\n         * @usage https://api.mangadex.org/chapter/:chapterId\r\n         * @see https://api.mangadex.org/docs/redoc.html#tag/Chapter/operation/get-chapter-id\r\n         */\r\n        MANGA_CHAPTERS: 'https://mangadex.org/chapter/',\r\n\r\n        /**\r\n         * Base URL for fetching the manga cover details.\r\n         *\r\n         * @usage https://api.mangadex.org/cover/:coverId\r\n         * @usage https://api.mangadex.org/cover/?manga[]=:mangaId\r\n         * @see https://api.mangadex.org/docs/swagger.html#/Cover/get-cover\r\n         */\r\n        COVERS: 'https://api.mangadex.org/cover/',\r\n\r\n        /**\r\n         * Base URL to retrieve the cover image.\r\n         *\r\n         * @usage https://uploads.mangadex.org/covers/:manga-id/:cover-filename\r\n         * @usage https://uploads.mangadex.org/covers/:manga-id/:cover-filename.{256, 512}.jpg\r\n         * @see https://api.mangadex.org/docs/03-manga/covers/\r\n         */\r\n        COVER_IMAGE: 'https://uploads.mangadex.org/covers/',\r\n\r\n        /**\r\n         * Get all Manga reading status for logged User\r\n         *\r\n         * @usage https://api.mangadex.org/manga/status\r\n         * @note Requires authentication\r\n         * @see https://api.mangadex.org/docs/redoc.html#tag/Manga/operation/get-manga-status\r\n         */\r\n        READING_STATUSES: 'https://api.mangadex.org/manga/status',\r\n\r\n        /**\r\n         * Retrieve a token for accessing the MangaDex API.\r\n         *\r\n         * @note Need configuration\r\n         * @see https://api.mangadex.org/docs/02-authentication/personal-clients/\r\n         */\r\n        TOKEN: 'https://auth.mangadex.org/realms/mangadex/protocol/openid-connect/token',\r\n\r\n        /**\r\n         * Retrieve the user settings from MangaDex API.\r\n         *\r\n         * @note Requires authentication\r\n         * @see https://api.mangadex.org/docs/redoc.html#tag/Settings/operation/get-settings\r\n         */\r\n        SETTING: 'https://api.mangadex.org/settings',\r\n    },\r\n\r\n    TOKEN_EXPIRE: 15 * 60 - 10, // access token expires in 15 minutes, refresh 10 seconds earlier\r\n};\r\n","import got from '@/utils/got';\r\nimport cache from '@/utils/cache';\r\nimport { config } from '@/config';\r\nimport ConfigNotFoundError from '@/errors/types/config-not-found';\r\n\r\nimport constants from './_constants';\r\nimport { FetchError } from 'ofetch';\r\n\r\n/**\r\n * Retrieves an access token.\r\n *\r\n * @important Ensure the request includes a User-Agent header.\r\n * @throws {ConfigNotFoundError} If the required configuration is missing.\r\n * The following credentials are mandatory:\r\n * - `client ID` and `client secret`\r\n * - One of the following:\r\n *   - `username` and `password`\r\n *   - `refresh token`\r\n * @throws {FetchError} If the request fails.\r\n * - 400 Bad Request: If the `refresh token` or other credentials are invalid.\r\n * @returns {Promise<string>} A promise that resolves to the access token.\r\n */\r\nconst getToken = () => {\r\n    if (!config.mangadex.clientId || !config.mangadex.clientSecret) {\r\n        throw new ConfigNotFoundError('Cannot get access token since MangaDex client ID or secret is not set.');\r\n    }\r\n\r\n    return cache.tryGet(\r\n        'mangadex:access-token',\r\n        async () => {\r\n            if (!config.mangadex.refreshToken) {\r\n                return getAccessTokenByUserCredentials();\r\n            }\r\n\r\n            try {\r\n                return await getAccessTokenByRefreshToken();\r\n            } catch (error) {\r\n                if (error instanceof FetchError && error.statusCode === 400) {\r\n                    // If the refresh token is invalid, try to get a new one with the user credentials\r\n                    return getAccessTokenByUserCredentials();\r\n                }\r\n                throw error;\r\n            }\r\n        },\r\n        constants.TOKEN_EXPIRE,\r\n        false\r\n    );\r\n};\r\n\r\nconst getAccessTokenByUserCredentials = async () => {\r\n    if (!config.mangadex.clientId || !config.mangadex.clientSecret) {\r\n        throw new ConfigNotFoundError('Cannot get access token since MangaDex client ID or secret is not set.');\r\n    }\r\n\r\n    if (!config.mangadex.username || !config.mangadex.password) {\r\n        throw new ConfigNotFoundError('Cannot get refresh token since MangaDex username or password is not set');\r\n    }\r\n\r\n    const response = await got.post(constants.API.TOKEN, {\r\n        headers: {\r\n            'User-Agent': config.trueUA,\r\n        },\r\n        form: {\r\n            grant_type: 'password',\r\n            username: config.mangadex.username,\r\n            password: config.mangadex.password,\r\n            client_id: config.mangadex.clientId,\r\n            client_secret: config.mangadex.clientSecret,\r\n        },\r\n    });\r\n\r\n    const refreshToken = response?.data?.refresh_token;\r\n    const accessToken = response?.data?.access_token;\r\n\r\n    if (!refreshToken || !accessToken) {\r\n        throw new Error('Failed to retrieve refresh token from MangaDex API.');\r\n    }\r\n\r\n    config.mangadex.refreshToken = refreshToken; // cache the refresh token\r\n    return accessToken;\r\n};\r\n\r\nconst getAccessTokenByRefreshToken = async () => {\r\n    if (!config.mangadex.clientId || !config.mangadex.clientSecret) {\r\n        throw new ConfigNotFoundError('Cannot get access token since MangaDex client ID or secret is not set.');\r\n    }\r\n\r\n    if (!config.mangadex.refreshToken) {\r\n        throw new ConfigNotFoundError('Cannot get access token since MangaDex refresh token is not set.');\r\n    }\r\n\r\n    const response = await got.post(constants.API.TOKEN, {\r\n        headers: {\r\n            'User-Agent': config.trueUA,\r\n        },\r\n        form: {\r\n            grant_type: 'refresh_token',\r\n            refresh_token: config.mangadex.refreshToken,\r\n            client_id: config.mangadex.clientId,\r\n            client_secret: config.mangadex.clientSecret,\r\n        },\r\n    });\r\n\r\n    const accessToken = response?.data?.access_token;\r\n    if (!accessToken) {\r\n        throw new Error('Failed to retrieve access token from MangaDex API.');\r\n    }\r\n    return accessToken;\r\n};\r\n\r\nexport default getToken;\r\n","import got from '@/utils/got';\r\nimport { config } from '@/config';\r\nimport cache from '@/utils/cache';\r\nimport ConfigNotFoundError from '@/errors/types/config-not-found';\r\nimport getToken from './_access';\r\n\r\nimport constants from './_constants';\r\n\r\nconst getSetting = async () => {\r\n    const accessToken = await getToken();\r\n\r\n    return cache.tryGet(\r\n        'mangadex:settings',\r\n        async () => {\r\n            const response = await got.get(constants.API.SETTING, {\r\n                headers: {\r\n                    Authorization: `Bearer ${accessToken}`,\r\n                    'User-Agent': config.trueUA,\r\n                },\r\n            });\r\n\r\n            const setting = response?.data?.settings;\r\n            if (!setting) {\r\n                throw new Error('Failed to retrieve user settings from MangaDex API.');\r\n            }\r\n\r\n            return setting;\r\n        },\r\n        config.cache.contentExpire,\r\n        false\r\n    );\r\n};\r\n\r\nconst getFilteredLanguages = async (ingoreConfigNotFountError: boolean = true) => {\r\n    try {\r\n        const settings = (await getSetting()) as any;\r\n        return settings.userPreferences.filteredLanguages as string[];\r\n    } catch (error) {\r\n        if (ingoreConfigNotFountError && error instanceof ConfigNotFoundError) {\r\n            return [];\r\n        }\r\n        throw error;\r\n    }\r\n};\r\n\r\nexport default getSetting;\r\nexport { getFilteredLanguages };\r\n","/**\r\n * Get the first value that matches the keys in the source object\r\n *\r\n * @param source the source object\r\n * @param keys the keys to search\r\n * @returns the first match value, or the first value as fallback\r\n */\r\nexport const firstMatch = (source: Map<string, string> | object, keys: string[]) => {\r\n    for (const key of keys) {\r\n        const value = source instanceof Map ? source.get(key) : source[key];\r\n        if (value) {\r\n            return value;\r\n        }\r\n    }\r\n    return Object.values(source)[0];\r\n};\r\n\r\n/**\r\n * Convert parameters to query string\r\n *\r\n * @param params parameters to be converted to query string\r\n * @returns the query string\r\n * @usage toQueryString({ a: 1, b: '2', c: [3, 4], d: {5: 'five', 6: 'six'} })\r\n *   >> '?a=1&b=2&c[]=3&c[]=4&d[5]=five&d[6]=six'\r\n */\r\nexport function toQueryString(params: Record<string, any>): string {\r\n    const queryParts: string[] = [];\r\n\r\n    for (const [key, value] of Object.entries(params)) {\r\n        if (typeof value === 'object' && !Array.isArray(value) && !(value instanceof Set)) {\r\n            for (const [subKey, subValue] of Object.entries(value)) {\r\n                if (typeof subValue === 'string' || typeof subValue === 'number' || typeof subValue === 'boolean') {\r\n                    queryParts.push(`${encodeURIComponent(key)}[${encodeURIComponent(subKey)}]=${encodeURIComponent(subValue)}`);\r\n                }\r\n            }\r\n        } else if (Array.isArray(value) || value instanceof Set) {\r\n            for (const item of value) {\r\n                queryParts.push(`${encodeURIComponent(key)}[]=${encodeURIComponent(item)}`);\r\n            }\r\n        } else {\r\n            queryParts.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\r\n        }\r\n    }\r\n\r\n    if (queryParts.length === 0) {\r\n        return '';\r\n    }\r\n    return '?' + queryParts.join('&');\r\n}\r\n","import got from '@/utils/got';\r\nimport { config } from '@/config';\r\nimport cache from '@/utils/cache';\r\nimport md5 from '@/utils/md5';\r\nimport { getFilteredLanguages } from './_profile';\r\nimport { toQueryString, firstMatch } from './_utils';\r\nimport constants from './_constants';\r\n\r\n/**\r\n * Retrieves the title, description, and cover of a manga.\r\n *\r\n * @author chrisis58, vzz64\r\n * @param id manga id\r\n * @param lang language(s), absent for default\r\n * @param needCover whether to fetch cover\r\n * @returns title, description, and cover of the manga\r\n */\r\nconst getMangaMeta = async (id: string, needCover: boolean = true, lang?: string | string[]) => {\r\n    const includes = needCover ? ['cover_art'] : [];\r\n\r\n    const rawMangaMeta = (await cache.tryGet(`mangadex:manga-meta:${id}`, async () => {\r\n        const { data } = await got.get(\r\n            `${constants.API.MANGA_META}${id}${toQueryString({\r\n                includes,\r\n            })}`\r\n        );\r\n\r\n        if (data.result === 'error') {\r\n            throw new Error(data.errors[0].detail);\r\n        }\r\n        return data.data;\r\n    })) as any;\r\n\r\n    const relationships = (rawMangaMeta.relationships || []) as Array<{ type: string; id: string; attributes: any }>;\r\n\r\n    const languages = [\r\n        ...(typeof lang === 'string' ? [lang] : lang || []),\r\n        ...(await getFilteredLanguages()),\r\n        rawMangaMeta.attributes.originalLanguage, // fallback to original language\r\n    ].filter(Boolean);\r\n\r\n    // combine title and altTitles\r\n    const titles = {\r\n        ...rawMangaMeta.attributes.title,\r\n        ...Object.fromEntries(rawMangaMeta.attributes.altTitles.flatMap((element) => Object.entries(element))),\r\n    };\r\n\r\n    const title = firstMatch(titles, languages) as string;\r\n\r\n    const description = firstMatch(rawMangaMeta.attributes.description, languages) as string;\r\n\r\n    if (!needCover) {\r\n        return { title, description };\r\n    }\r\n\r\n    const coverFilename = relationships.find((relationship) => relationship.type === 'cover_art')?.attributes.fileName + '.512.jpg';\r\n    const cover = `${constants.API.COVER_IMAGE}${id}/${coverFilename}`;\r\n\r\n    return { title, description, cover };\r\n};\r\n\r\n/**\r\n * Retrieves the title, description, and cover of multiple manga.\r\n * TODO: Retrieve page by page to avoid meeting the length limit of URL.\r\n *\r\n * @param ids manga ids\r\n * @param needCover whether to fetch cover\r\n * @param lang language(s), absent for default\r\n * @returns a map of manga id to title, description, and cover\r\n * @usage const mangaMetaMap = await getMangaMetaByIds(['f98660a1-d2e2-461c-960d-7bd13df8b76d']);\r\n */\r\nexport async function getMangaMetaByIds(ids: string[], needCover: boolean = true, lang?: string | string[]): Promise<Map<string, { id: string; title: string; description: string; cover?: string }>> {\r\n    const deDuplidatedIds = [...new Set(ids)].sort();\r\n    const includes = needCover ? ['cover_art'] : [];\r\n\r\n    const rawMangaMetas = (await cache.tryGet(\r\n        `mangadex:manga-meta:${md5(deDuplidatedIds.join(''))}`, // shorten the key\r\n        async () => {\r\n            const { data } = await got.get(\r\n                constants.API.MANGA_META.slice(0, -1) +\r\n                    toQueryString({\r\n                        ids: deDuplidatedIds,\r\n                        includes,\r\n                        limit: deDuplidatedIds.length,\r\n                    })\r\n            );\r\n\r\n            if (data.result === 'error') {\r\n                throw new Error('Failed to retrieve manga meta from MangaDex API.');\r\n            }\r\n            return data.data;\r\n        }\r\n    )) as Array<any>;\r\n\r\n    const languages = [...(typeof lang === 'string' ? [lang] : lang || []), ...(await getFilteredLanguages())].filter(Boolean);\r\n\r\n    const map = new Map<string, { id: string; title: string; description: string; cover?: string }>();\r\n    for (const rawMangaMeta of rawMangaMetas) {\r\n        const id = rawMangaMeta.id;\r\n\r\n        const titles = {\r\n            ...rawMangaMeta.attributes.title,\r\n            ...Object.fromEntries(rawMangaMeta.attributes.altTitles.flatMap((element) => Object.entries(element))),\r\n        };\r\n\r\n        const title = firstMatch(titles, [...languages, rawMangaMeta.attributes.originalLanguage]) as string;\r\n\r\n        const description = firstMatch(rawMangaMeta.attributes.description, languages) as string;\r\n\r\n        let cover: string | undefined;\r\n        let manga = { id, title, description, cover };\r\n\r\n        if (needCover) {\r\n            const coverFilename = rawMangaMeta.relationships.find((relationship) => relationship.type === 'cover_art')?.attributes.fileName;\r\n            if (coverFilename) {\r\n                cover = `${constants.API.COVER_IMAGE}${rawMangaMeta.id}/${coverFilename}.512.jpg`;\r\n                manga = { ...manga, cover };\r\n            }\r\n        }\r\n\r\n        map.set(id, manga);\r\n    }\r\n    return map;\r\n}\r\n\r\n/**\r\n * Retrieves the chapters of a manga.\r\n *\r\n * @author chrisis58, vzz64\r\n * @param id manga id\r\n * @param lang language(s), absent for default\r\n * @returns chapters of the manga\r\n */\r\nconst getMangaChapters = async (id: string, lang?: string | string[], limit?: number) => {\r\n    const languages = new Set([...(typeof lang === 'string' ? [lang] : lang || []), ...(await getFilteredLanguages())].filter(Boolean));\r\n\r\n    const url = `${constants.API.MANGA_META}${id}/feed${toQueryString({\r\n        order: {\r\n            publishAt: 'desc',\r\n        },\r\n        limit: limit || 100,\r\n        translatedLanguage: languages,\r\n    })}`;\r\n\r\n    const chapters = (await cache.tryGet(\r\n        `mangadex:manga-chapters:${id}`,\r\n        async () => {\r\n            const { data } = await got.get(url);\r\n\r\n            if (data.result === 'error') {\r\n                throw new Error(data.errors[0].detail);\r\n            }\r\n\r\n            return data.data;\r\n        },\r\n        config.cache.routeExpire,\r\n        false\r\n    )) as any;\r\n\r\n    if (!chapters) {\r\n        return [];\r\n    }\r\n\r\n    return chapters.map((chapter) => ({\r\n        title: [chapter.attributes.volume ? `Vol. ${chapter.attributes.volume}` : null, chapter.attributes.chapter ? `Ch. ${chapter.attributes.chapter}` : null, chapter.attributes.title].filter(Boolean).join(' '),\r\n        link: `${constants.API.MANGA_CHAPTERS}${chapter.id}`,\r\n        pubDate: new Date(chapter.attributes.publishAt),\r\n    })) as Array<{ title: string; link: string; pubDate: Date }>;\r\n};\r\n\r\n/**\r\n * Retrieves the title, description, cover, and chapters of a manga.\r\n * Cominbation of getMangaMeta and getMangaChapters.\r\n *\r\n * @param id manga id\r\n * @param lang language, absent for default\r\n * @returns title, description, cover, and chapters of the manga\r\n */\r\nconst getMangaDetails = async (id: string, needCover: boolean = true, lang?: string | string[]) => {\r\n    const [meta, chapters] = await Promise.all([getMangaMeta(id, needCover, lang), getMangaChapters(id, lang)]);\r\n    return { ...meta, chapters };\r\n};\r\n\r\nexport { getMangaMeta, getMangaChapters, getMangaDetails };\r\n"],"mappings":"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"}