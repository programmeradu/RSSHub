{"version":3,"file":"dist-IvUHtNe1.js","names":["_","k","y","g","w","D","I","M","P","d","x","BINARY_TYPES","hasBlob","runtimeRequire","dir","platform","arch","extension","runtime","abi","mask","unmask","FastBuffer","concat","EMPTY_BUFFER","mask","toArrayBuffer","toBuffer","bufferUtil","Limiter","FastBuffer","kError","PerMessageDeflate","data","kStatusCode","isValidUTF8","tokenChars","isValidStatusCode","isBlob","isValidUTF8","PerMessageDeflate","Receiver","BINARY_TYPES","kWebSocket","EMPTY_BUFFER","isValidStatusCode","kStatusCode","PerMessageDeflate","Sender","NOOP","kWebSocket","mask","EMPTY_BUFFER","isBlob","toBuffer","kForOnEventAttribute","kListener","onError","parse","tokenChars","format","extension","k","EventEmitter","http","PerMessageDeflate","Receiver","Sender","WebSocket","kWebSocket","socketOnError","mask","URL","key","createHash","GUID","parse","abortHandshake","emitClose","createWebSocketStream","Duplex","err","protocol","WebSocket","WebSocketServer"],"sources":["../../node_modules/.pnpm/node-network-devtools@1.0.2_0b90ec5ec7d042f7e8906189958d50b1/node_modules/node-network-devtools/dist/common-BUk9ORDJ.mjs","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/constants.js","../../node_modules/.pnpm/node-gyp-build@4.8.4/node_modules/node-gyp-build/node-gyp-build.js","../../node_modules/.pnpm/node-gyp-build@4.8.4/node_modules/node-gyp-build/index.js","../../node_modules/.pnpm/bufferutil@4.0.9/node_modules/bufferutil/fallback.js","../../node_modules/.pnpm/bufferutil@4.0.9/node_modules/bufferutil/index.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/buffer-util.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/limiter.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/permessage-deflate.js","../../node_modules/.pnpm/utf-8-validate@5.0.10/node_modules/utf-8-validate/fallback.js","../../node_modules/.pnpm/utf-8-validate@5.0.10/node_modules/utf-8-validate/index.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/validation.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/receiver.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/sender.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/event-target.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/extension.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/websocket.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/stream.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/subprotocol.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/lib/websocket-server.js","../../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/wrapper.mjs","../../node_modules/.pnpm/node-network-devtools@1.0.2_0b90ec5ec7d042f7e8906189958d50b1/node_modules/node-network-devtools/dist/index.mjs"],"sourcesContent":["import { fileURLToPath as d } from \"url\";\nimport { dirname as x } from \"path\";\nclass u {\n  constructor(e) {\n    typeof e == \"string\" && this.parse(e), e instanceof u && Object.assign(this, e);\n  }\n  parse(e) {\n    if (e.match(/^\\s*[-]{4,}$/))\n      return this.fileName = e, this;\n    const n = /at (?:(.+?)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/, t = e.match(n);\n    if (!t)\n      return this;\n    let r = null, o = null, i = null, m = null, c = null, f = t[5] === \"native\";\n    if (t[1]) {\n      i = t[1];\n      let a = i.lastIndexOf(\".\");\n      if (i[a - 1] == \".\" && a--, a > 0) {\n        r = i.substr(0, a), o = i.substr(a + 1);\n        const l = r.indexOf(\".Module\");\n        l > 0 && (i = i.substr(l + 1), r = r.substr(0, l));\n      }\n    }\n    o && (m = r, c = o), o === \"<anonymous>\" && (c = null, i = null);\n    const h = {\n      fileName: t[2] || null,\n      lineNumber: parseInt(t[3], 10) || null,\n      functionName: i,\n      typeName: m,\n      methodName: c,\n      columnNumber: parseInt(t[4], 10) || null,\n      native: f\n    };\n    return Object.assign(this, h), this;\n  }\n  valueOf() {\n    return {\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      functionName: this.functionName,\n      typeName: this.typeName,\n      methodName: this.methodName,\n      columnNumber: this.columnNumber,\n      native: this.native\n    };\n  }\n  toString() {\n    return JSON.stringify(this.valueOf());\n  }\n}\nconst p = [\n  /* node:async_hooks */\n  /\\((internal\\/)?async_hooks\\.js:/,\n  /* external */\n  /\\(\\//,\n  /* node_modules */\n  /node_modules/\n];\nfunction N(s) {\n  const e = /* @__PURE__ */ Object.create(null);\n  return s ? e.stack = s : (Error.stackTraceLimit = 1 / 0, Error.captureStackTrace(e)), e.stack.split(`\n`).slice(1).map((r) => new u(r));\n}\nfunction b(s) {\n  return s.filter((n) => !p.some((t) => t.test(n.fileName || \"\")));\n}\nconst T = console.log.bind(console, \"\\x1B[36m[node-network-debugger]:\", \"\\x1B[32m\"), _ = console.warn.bind(console, \"\\x1B[36m[node-network-debugger](warn):\", \"\\x1B[33m\"), k = (s, e) => s + Object.entries(e).map(([n, t]) => `${n}: ${String(t)}`).join(`\\r\n`), y = (s) => s.reduce(\n  (e, n, t, r) => t % 2 === 0 ? { ...e, [r[t]]: r[t + 1] } : e,\n  {}\n), g = (s) => Object.keys(s).reduce((e, n) => {\n  const t = s[n];\n  return e[n] = typeof t == \"object\" && t !== null ? g(t) : String(t), e;\n}, {}), w = () => (/* @__PURE__ */ new Date()).getTime() / 1e3;\nfunction E() {\n  let s = (/* @__PURE__ */ new Date()).getTime();\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(n) {\n    const t = (s + Math.random() * 16) % 16 | 0;\n    return s = Math.floor(s / 16), (n === \"x\" ? t : t & 3 | 8).toString(16);\n  });\n}\nfunction v(s) {\n  let e = 0, n, t;\n  if (s.length === 0) return e.toString(36);\n  for (n = 0; n < s.length; n++)\n    t = s.charCodeAt(n), e = (e << 5) - e + t, e |= 0;\n  return e.toString(36);\n}\nclass j {\n  constructor(e) {\n    e ? (this.id = e.id, this.responseInfo = e.responseInfo, Object.assign(this, e)) : (this.id = E(), this.responseInfo = {});\n  }\n  loadCallFrames(e) {\n    const t = b(N(e)).map((r) => {\n      const o = r.fileName || \"\";\n      return {\n        columnNumber: r.columnNumber || 0,\n        functionName: r.functionName || \"\",\n        lineNumber: r.lineNumber || 0,\n        url: o.startsWith(\"/\") ? `file://${o}` : o\n      };\n    });\n    t.length > 0 && (this.initiator = {\n      type: \"script\",\n      stack: {\n        callFrames: t\n      }\n    });\n  }\n  isHiden() {\n    return this.isWebSocket() && [\"http://localhost/\", \"ws://localhost/\"].includes(this.url);\n  }\n  isWebSocket() {\n    return this.requestHeaders?.Upgrade === \"websocket\" || this.requestHeaders?.upgrade === \"websocket\";\n  }\n}\nconst D = Number(process.env.NETWORK_PORT || 5270), I = Number(process.env.NETWORK_SERVER_PORT || 5271), M = Number(process.env.REMOTE_DEBUGGER_PORT || 9333), P = process.env.NETWORK_DEBUG_MODE === \"true\", B = \"ready\", O = d(import.meta.url), H = x(O);\nexport {\n  P as I,\n  D as P,\n  j as R,\n  I as S,\n  H as _,\n  B as a,\n  v as b,\n  M as c,\n  k as f,\n  w as g,\n  T as l,\n  y as p,\n  g as s,\n  _ as w\n};\n","'use strict';\n\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nconst hasBlob = typeof Blob !== 'undefined';\n\nif (hasBlob) BINARY_TYPES.push('blob');\n\nmodule.exports = {\n  BINARY_TYPES,\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  hasBlob,\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n","var fs = require('fs')\nvar path = require('path')\nvar os = require('os')\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\n\nvar vars = (process.config && process.config.variables) || {}\nvar prebuildsOnly = !!process.env.PREBUILDS_ONLY\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : (isNwjs() ? 'node-webkit' : 'node')\n\nvar arch = process.env.npm_config_arch || os.arch()\nvar platform = process.env.npm_config_platform || os.platform()\nvar libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')\nvar armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''\nvar uv = (process.versions.uv || '').split('.')[0]\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.resolve(dir))\n}\n\nload.resolve = load.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  if (!prebuildsOnly) {\n    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n    if (release) return release\n\n    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n    if (debug) return debug\n  }\n\n  var prebuild = resolve(dir)\n  if (prebuild) return prebuild\n\n  var nearby = resolve(path.dirname(process.execPath))\n  if (nearby) return nearby\n\n  var target = [\n    'platform=' + platform,\n    'arch=' + arch,\n    'runtime=' + runtime,\n    'abi=' + abi,\n    'uv=' + uv,\n    armv ? 'armv=' + armv : '',\n    'libc=' + libc,\n    'node=' + process.versions.node,\n    process.versions.electron ? 'electron=' + process.versions.electron : '',\n    typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line\n  ].filter(Boolean).join(' ')\n\n  throw new Error('No native build was found for ' + target + '\\n    loaded from: ' + dir + '\\n')\n\n  function resolve (dir) {\n    // Find matching \"prebuilds/<platform>-<arch>\" directory\n    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)\n    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]\n    if (!tuple) return\n\n    // Find most specific flavor first\n    var prebuilds = path.join(dir, 'prebuilds', tuple.name)\n    var parsed = readdirSync(prebuilds).map(parseTags)\n    var candidates = parsed.filter(matchTags(runtime, abi))\n    var winner = candidates.sort(compareTags(runtime))[0]\n    if (winner) return path.join(prebuilds, winner.file)\n  }\n}\n\nfunction readdirSync (dir) {\n  try {\n    return fs.readdirSync(dir)\n  } catch (err) {\n    return []\n  }\n}\n\nfunction getFirst (dir, filter) {\n  var files = readdirSync(dir).filter(filter)\n  return files[0] && path.join(dir, files[0])\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction parseTuple (name) {\n  // Example: darwin-x64+arm64\n  var arr = name.split('-')\n  if (arr.length !== 2) return\n\n  var platform = arr[0]\n  var architectures = arr[1].split('+')\n\n  if (!platform) return\n  if (!architectures.length) return\n  if (!architectures.every(Boolean)) return\n\n  return { name, platform, architectures }\n}\n\nfunction matchTuple (platform, arch) {\n  return function (tuple) {\n    if (tuple == null) return false\n    if (tuple.platform !== platform) return false\n    return tuple.architectures.includes(arch)\n  }\n}\n\nfunction compareTuples (a, b) {\n  // Prefer single-arch prebuilds over multi-arch\n  return a.architectures.length - b.architectures.length\n}\n\nfunction parseTags (file) {\n  var arr = file.split('.')\n  var extension = arr.pop()\n  var tags = { file: file, specificity: 0 }\n\n  if (extension !== 'node') return\n\n  for (var i = 0; i < arr.length; i++) {\n    var tag = arr[i]\n\n    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {\n      tags.runtime = tag\n    } else if (tag === 'napi') {\n      tags.napi = true\n    } else if (tag.slice(0, 3) === 'abi') {\n      tags.abi = tag.slice(3)\n    } else if (tag.slice(0, 2) === 'uv') {\n      tags.uv = tag.slice(2)\n    } else if (tag.slice(0, 4) === 'armv') {\n      tags.armv = tag.slice(4)\n    } else if (tag === 'glibc' || tag === 'musl') {\n      tags.libc = tag\n    } else {\n      continue\n    }\n\n    tags.specificity++\n  }\n\n  return tags\n}\n\nfunction matchTags (runtime, abi) {\n  return function (tags) {\n    if (tags == null) return false\n    if (tags.runtime && tags.runtime !== runtime && !runtimeAgnostic(tags)) return false\n    if (tags.abi && tags.abi !== abi && !tags.napi) return false\n    if (tags.uv && tags.uv !== uv) return false\n    if (tags.armv && tags.armv !== armv) return false\n    if (tags.libc && tags.libc !== libc) return false\n\n    return true\n  }\n}\n\nfunction runtimeAgnostic (tags) {\n  return tags.runtime === 'node' && tags.napi\n}\n\nfunction compareTags (runtime) {\n  // Precedence: non-agnostic runtime, abi over napi, then by specificity.\n  return function (a, b) {\n    if (a.runtime !== b.runtime) {\n      return a.runtime === runtime ? -1 : 1\n    } else if (a.abi !== b.abi) {\n      return a.abi ? -1 : 1\n    } else if (a.specificity !== b.specificity) {\n      return a.specificity > b.specificity ? -1 : 1\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction isNwjs () {\n  return !!(process.versions && process.versions.nw)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\nfunction isAlpine (platform) {\n  return platform === 'linux' && fs.existsSync('/etc/alpine-release')\n}\n\n// Exposed for unit tests\n// TODO: move to lib\nload.parseTags = parseTags\nload.matchTags = matchTags\nload.compareTags = compareTags\nload.parseTuple = parseTuple\nload.matchTuple = matchTuple\nload.compareTuples = compareTuples\n","const runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\nif (typeof runtimeRequire.addon === 'function') { // if the platform supports native resolving prefer that\n  module.exports = runtimeRequire.addon.bind(runtimeRequire)\n} else { // else use the runtime version here\n  module.exports = require('./node-gyp-build.js')\n}\n","'use strict';\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nconst mask = (source, mask, output, offset, length) => {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n};\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nconst unmask = (buffer, mask) => {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n};\n\nmodule.exports = { mask, unmask };\n","'use strict';\n\ntry {\n  module.exports = require('node-gyp-build')(__dirname);\n} catch (e) {\n  module.exports = require('./fallback');\n}\n","'use strict';\n\nconst { EMPTY_BUFFER } = require('./constants');\n\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = require('bufferutil');\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n","'use strict';\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n","'use strict';\n\nconst zlib = require('zlib');\n\nconst bufferUtil = require('./buffer-util');\nconst Limiter = require('./limiter');\nconst { kStatusCode } = require('./constants');\n\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n\n  //\n  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the\n  // fact that in Node.js versions prior to 13.10.0, the callback for\n  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing\n  // `zlib.reset()` ensures that either the callback is invoked or an error is\n  // emitted.\n  //\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n\n  if (this[kError]) {\n    this[kCallback](this[kError]);\n    return;\n  }\n\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n","'use strict';\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0x00) {  // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0  // overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong\n        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0  // surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong\n        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = isValidUTF8;\n","'use strict';\n\ntry {\n  module.exports = require('node-gyp-build')(__dirname);\n} catch (e) {\n  module.exports = require('./fallback');\n}\n","'use strict';\n\nconst { isUtf8 } = require('buffer');\n\nconst { hasBlob } = require('./constants');\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */\nfunction isBlob(value) {\n  return (\n    hasBlob &&\n    typeof value === 'object' &&\n    typeof value.arrayBuffer === 'function' &&\n    typeof value.type === 'string' &&\n    typeof value.stream === 'function' &&\n    (value[Symbol.toStringTag] === 'Blob' ||\n      value[Symbol.toStringTag] === 'File')\n  );\n}\n\nmodule.exports = {\n  isBlob,\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\n\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = require('utf-8-validate');\n\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n","'use strict';\n\nconst { Writable } = require('stream');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = require('./constants');\nconst { concat, toArrayBuffer, unmask } = require('./buffer-util');\nconst { isValidStatusCode, isValidUTF8 } = require('./validation');\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._allowSynchronousEvents =\n      options.allowSynchronousEvents !== undefined\n        ? options.allowSynchronousEvents\n        : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n\n      cb(error);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (!this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (\n        this._payloadLength > 0x7d ||\n        (this._opcode === 0x08 && this._payloadLength === 1)\n      ) {\n        const error = this.createError(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(\n            RangeError,\n            'Max payload size exceeded',\n            false,\n            1009,\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._fragments.push(buf);\n      }\n\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n\n    if (this._opcode === 2) {\n      let data;\n\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else if (this._binaryType === 'blob') {\n        data = new Blob(fragments);\n      } else {\n        data = fragments;\n      }\n\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(\n          Error,\n          'invalid UTF-8 sequence',\n          true,\n          1007,\n          'WS_ERR_INVALID_UTF8'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n\n          cb(error);\n          return;\n        }\n\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n\n      this._state = GET_INFO;\n      return;\n    }\n\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n\n    const err = new ErrorCtor(\n      prefix ? `Invalid WebSocket frame: ${message}` : message\n    );\n\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\n\nmodule.exports = Receiver;\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */\n\n'use strict';\n\nconst { Duplex } = require('stream');\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = require('./constants');\nconst { isBlob, isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\n\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._queue = [];\n    this._state = DEFAULT;\n    this.onerror = NOOP;\n    this[kWebSocket] = undefined;\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        if (randomPoolPointer === RANDOM_POOL_SIZE) {\n          /* istanbul ignore else  */\n          if (randomPool === undefined) {\n            //\n            // This is lazily initialized because server-sent frames must not\n            // be masked so it may never be used.\n            //\n            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n          }\n\n          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n          randomPoolPointer = 0;\n        }\n\n        mask[0] = randomPool[randomPoolPointer++];\n        mask[1] = randomPool[randomPoolPointer++];\n        mask[2] = randomPool[randomPoolPointer++];\n        mask[3] = randomPool[randomPoolPointer++];\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    const opts = {\n      [kByteLength]: byteLength,\n      fin: options.fin,\n      generateMask: this._generateMask,\n      mask: options.mask,\n      maskBuffer: this._maskBuffer,\n      opcode,\n      readOnly,\n      rsv1\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);\n      } else {\n        this.getBlobData(data, this._compress, opts, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n    } else {\n      this.dispatch(data, this._compress, opts, cb);\n    }\n  }\n\n  /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  getBlobData(blob, compress, options, cb) {\n    this._bufferedBytes += options[kByteLength];\n    this._state = GET_BLOB_DATA;\n\n    blob\n      .arrayBuffer()\n      .then((arrayBuffer) => {\n        if (this._socket.destroyed) {\n          const err = new Error(\n            'The socket was closed while the blob was being read'\n          );\n\n          //\n          // `callCallbacks` is called in the next tick to ensure that errors\n          // that might be thrown in the callbacks behave like errors thrown\n          // outside the promise chain.\n          //\n          process.nextTick(callCallbacks, this, err, cb);\n          return;\n        }\n\n        this._bufferedBytes -= options[kByteLength];\n        const data = toBuffer(arrayBuffer);\n\n        if (!compress) {\n          this._state = DEFAULT;\n          this.sendFrame(Sender.frame(data, options), cb);\n          this.dequeue();\n        } else {\n          this.dispatch(data, compress, options, cb);\n        }\n      })\n      .catch((err) => {\n        //\n        // `onError` is called in the next tick for the same reason that\n        // `callCallbacks` above is.\n        //\n        process.nextTick(onError, this, err, cb);\n      });\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._state = DEFLATING;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        callCallbacks(this, err, cb);\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._state = DEFAULT;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (this._state === DEFAULT && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {(Buffer | String)[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */\nfunction callCallbacks(sender, err, cb) {\n  if (typeof cb === 'function') cb(err);\n\n  for (let i = 0; i < sender._queue.length; i++) {\n    const params = sender._queue[i];\n    const callback = params[params.length - 1];\n\n    if (typeof callback === 'function') callback(err);\n  }\n}\n\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */\nfunction onError(sender, err, cb) {\n  callCallbacks(sender, err, cb);\n  sender.onerror(err);\n}\n","'use strict';\n\nconst { kForOnEventAttribute, kListener } = require('./constants');\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (\n        !options[kForOnEventAttribute] &&\n        listener[kListener] === handler &&\n        !listener[kForOnEventAttribute]\n      ) {\n        return;\n      }\n    }\n\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\n","'use strict';\n\nconst { tokenChars } = require('./validation');\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { Duplex, Readable } = require('stream');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst { isBlob } = require('./validation');\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._errorEmitted = false;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    const sender = new Sender(socket, this._extensions, options.generateMask);\n\n    this._receiver = receiver;\n    this._sender = sender;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    sender[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    sender.onerror = senderOnError;\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    setCloseTimer(this);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  websocket._autoPong = opts.autoPong;\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n\n  websocket._url = parsedUrl.href;\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\n      '\"http:\", \"https:\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection =\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl\n        ? websocket._originalIpc\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalIpc\n          ? false\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const upgrade = res.headers.upgrade;\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  //\n  // The following assignment is practically useless and is done only for\n  // consistency.\n  //\n  websocket._errorEmitted = true;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */\nfunction senderOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket.readyState === WebSocket.CLOSED) return;\n  if (websocket.readyState === WebSocket.OPEN) {\n    websocket._readyState = WebSocket.CLOSING;\n    setCloseTimer(websocket);\n  }\n\n  //\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\n  // peer to finish sending queued data. There is no need to set a timer here\n  // because `CLOSING` means that it is already set or not needed.\n  //\n  this._socket.end();\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */\nfunction setCloseTimer(websocket) {\n  websocket._closeTimer = setTimeout(\n    websocket._socket.destroy.bind(websocket._socket),\n    closeTimeout\n  );\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^WebSocket$\" }] */\n'use strict';\n\nconst WebSocket = require('./websocket');\nconst { Duplex } = require('stream');\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n","'use strict';\n\nconst { tokenChars } = require('./validation');\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst http = require('http');\nconst { Duplex } = require('stream');\nconst { createHash } = require('crypto');\n\nconst extension = require('./extension');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst subprotocol = require('./subprotocol');\nconst WebSocket = require('./websocket');\nconst { GUID, kWebSocket } = require('./constants');\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 13 && version !== 8) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {\n        'Sec-WebSocket-Version': '13, 8'\n      });\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @param {Object} [headers] The HTTP response headers\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(\n  server,\n  req,\n  socket,\n  code,\n  message,\n  headers\n) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message, headers);\n  }\n}\n","import createWebSocketStream from './lib/stream.js';\nimport Receiver from './lib/receiver.js';\nimport Sender from './lib/sender.js';\nimport WebSocket from './lib/websocket.js';\nimport WebSocketServer from './lib/websocket-server.js';\n\nexport { createWebSocketStream, Receiver, Sender, WebSocket, WebSocketServer };\nexport default WebSocket;\n","import ie from \"http\";\nimport W from \"https\";\nimport { R as Q, g as ne, _ as O, w as oe, a as ae, b as he, P as le, S as fe } from \"./common-BUk9ORDJ.mjs\";\nimport { Writable as ce } from \"stream\";\nimport y from \"node:zlib\";\nimport { isUtf8 as U } from \"node:buffer\";\nimport C from \"ws\";\nimport { fork as _e } from \"child_process\";\nimport { resolve as F } from \"path\";\nimport T from \"fs\";\nimport de from \"net\";\nimport v from \"undici\";\nfunction ee(i) {\n  const e = {};\n  return i.forEach((t, r) => {\n    e[r] = t;\n  }), e;\n}\nconst ue = typeof Blob < \"u\", A = [\n  \"nodebuffer\",\n  \"arraybuffer\",\n  \"fragments\",\n  ue ? \"blob\" : null\n].filter(Boolean), I = Buffer.alloc(0), pe = Symbol(\"status-code\"), me = Symbol(\"websocket\"), ge = Buffer[Symbol.species];\nfunction E(i, e) {\n  if (i.length === 0) return I;\n  if (i.length === 1) return i[0];\n  const t = Buffer.allocUnsafe(e);\n  let r = 0;\n  for (let s = 0; s < i.length; s++) {\n    const n = i[s];\n    t.set(n, r), r += n.length;\n  }\n  return r < e ? new ge(t.buffer, t.byteOffset, r) : t;\n}\nfunction we(i, e) {\n  for (let t = 0; t < i.length; t++)\n    i[t] ^= e[t & 3];\n}\nfunction ye(i) {\n  return i.length === i.buffer.byteLength ? i.buffer : i.buffer.slice(i.byteOffset, i.byteOffset + i.length);\n}\nconst D = Symbol(\"kDone\"), k = Symbol(\"kRun\");\nclass Ee {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(e = 1 / 0) {\n    this[D] = () => {\n      this.pending--, this[k]();\n    }, this.concurrency = e, this.jobs = [], this.pending = 0;\n  }\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(e) {\n    this.jobs.push(e), this[k]();\n  }\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [k]() {\n    if (this.pending !== this.concurrency && this.jobs.length) {\n      const e = this.jobs.shift();\n      this.pending++, e(this[D]);\n    }\n  }\n}\nconst Re = Buffer.from([0, 0, 255, 255]), M = Symbol(\"permessage-deflate\"), g = Symbol(\"total-length\"), R = Symbol(\"callback\"), w = Symbol(\"buffers\"), Se = Symbol(\"error\");\nlet b;\nclass q {\n  constructor(e = {}, t = !1, r = 0) {\n    if (this._maxPayload = r | 0, this._options = e, this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024, this._isServer = !!t, this._deflate = null, this._inflate = null, this.params = null, !b) {\n      const s = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;\n      b = new Ee(s);\n    }\n  }\n  static get extensionName() {\n    return \"permessage-deflate\";\n  }\n  offer() {\n    const e = {};\n    return this._options.serverNoContextTakeover && (e.server_no_context_takeover = !0), this._options.clientNoContextTakeover && (e.client_no_context_takeover = !0), this._options.serverMaxWindowBits && (e.server_max_window_bits = this._options.serverMaxWindowBits), this._options.clientMaxWindowBits ? e.client_max_window_bits = this._options.clientMaxWindowBits : this._options.clientMaxWindowBits == null && (e.client_max_window_bits = !0), e;\n  }\n  accept(e) {\n    return e = this.normalizeParams(e), this.params = this._isServer ? this.acceptAsServer(e) : this.acceptAsClient(e), this.params;\n  }\n  cleanup() {\n    if (this._inflate && (this._inflate.close(), this._inflate = null), this._deflate) {\n      const e = this._deflate[R];\n      this._deflate.close(), this._deflate = null, e && e(new Error(\"The deflate stream was closed while data was being processed\"));\n    }\n  }\n  acceptAsServer(e) {\n    const t = this._options, r = e.find((s) => !(t.serverNoContextTakeover === !1 && s.server_no_context_takeover || s.server_max_window_bits && (t.serverMaxWindowBits === !1 || typeof t.serverMaxWindowBits == \"number\" && t.serverMaxWindowBits > s.server_max_window_bits) || typeof t.clientMaxWindowBits == \"number\" && !s.client_max_window_bits));\n    if (!r)\n      throw new Error(\"None of the extension offers can be accepted\");\n    return t.serverNoContextTakeover && (r.server_no_context_takeover = !0), t.clientNoContextTakeover && (r.client_no_context_takeover = !0), typeof t.serverMaxWindowBits == \"number\" && (r.server_max_window_bits = t.serverMaxWindowBits), typeof t.clientMaxWindowBits == \"number\" ? r.client_max_window_bits = t.clientMaxWindowBits : (r.client_max_window_bits === !0 || t.clientMaxWindowBits === !1) && delete r.client_max_window_bits, r;\n  }\n  acceptAsClient(e) {\n    const t = e[0];\n    if (this._options.clientNoContextTakeover === !1 && t.client_no_context_takeover)\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    if (!t.client_max_window_bits)\n      typeof this._options.clientMaxWindowBits == \"number\" && (t.client_max_window_bits = this._options.clientMaxWindowBits);\n    else if (this._options.clientMaxWindowBits === !1 || typeof this._options.clientMaxWindowBits == \"number\" && t.client_max_window_bits > this._options.clientMaxWindowBits)\n      throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n    return t;\n  }\n  normalizeParams(e) {\n    return e.forEach((t) => {\n      Object.keys(t).forEach((r) => {\n        let s = t[r];\n        if (s.length > 1)\n          throw new Error(`Parameter \"${r}\" must have only a single value`);\n        if (s = s[0], r === \"client_max_window_bits\") {\n          if (s !== !0) {\n            const n = +s;\n            if (!Number.isInteger(n) || n < 8 || n > 15)\n              throw new TypeError(`Invalid value for parameter \"${r}\": ${s}`);\n            s = n;\n          } else if (!this._isServer)\n            throw new TypeError(`Invalid value for parameter \"${r}\": ${s}`);\n        } else if (r === \"server_max_window_bits\") {\n          const n = +s;\n          if (!Number.isInteger(n) || n < 8 || n > 15)\n            throw new TypeError(`Invalid value for parameter \"${r}\": ${s}`);\n          s = n;\n        } else if (r === \"client_no_context_takeover\" || r === \"server_no_context_takeover\") {\n          if (s !== !0)\n            throw new TypeError(`Invalid value for parameter \"${r}\": ${s}`);\n        } else\n          throw new Error(`Unknown parameter \"${r}\"`);\n        t[r] = s;\n      });\n    }), e;\n  }\n  decompress(e, t, r) {\n    b?.add((s) => {\n      this._decompress(e, t, (n, o) => {\n        s(), r(n, o);\n      });\n    });\n  }\n  compress(e, t, r) {\n    b?.add((s) => {\n      this._compress(e, t, (n, o) => {\n        s(), r(n, o);\n      });\n    });\n  }\n  _decompress(e, t, r) {\n    const s = this._isServer ? \"client\" : \"server\";\n    if (!this._inflate) {\n      const n = `${s}_max_window_bits`, o = typeof this.params[n] != \"number\" ? y.constants.Z_DEFAULT_WINDOWBITS : this.params[n];\n      this._inflate = y.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits: o\n      }), this._inflate[M] = this, this._inflate[g] = 0, this._inflate[w] = [], this._inflate.on(\"error\", ve), this._inflate.on(\"data\", be);\n    }\n    this._inflate[R] = r, this._inflate.write(e), t && this._inflate.write(Re), this._inflate.flush(() => {\n      const n = this._inflate[Se];\n      if (n) {\n        this._inflate.close(), this._inflate = null, r(n);\n        return;\n      }\n      const o = E(\n        this._inflate[w],\n        this._inflate[g]\n      );\n      if (this._maxPayload < 1 || o.length <= this._maxPayload) {\n        r(null, o);\n        return;\n      }\n      r(new RangeError(\"Max payload size exceeded\"), null);\n    });\n  }\n  _compress(e, t, r) {\n    const s = this._isServer ? \"server\" : \"client\";\n    if (!this._deflate) {\n      const n = `${s}_max_window_bits`, o = typeof this.params[n] != \"number\" ? y.constants.Z_DEFAULT_WINDOWBITS : this.params[n];\n      this._deflate = y.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits: o\n      }), this._deflate[g] = 0, this._deflate[w] = [], this._deflate.on(\"error\", xe), this._deflate.on(\"data\", Le);\n    }\n    this._deflate[R] = r, this._deflate.write(e), t && this._deflate.flush(y.Z_SYNC_FLUSH, () => {\n      const n = E(\n        this._deflate[w],\n        this._deflate[g]\n      );\n      if (this._maxPayload < 1 || n.length <= this._maxPayload) {\n        r(null, n);\n        return;\n      }\n      r(new RangeError(\"Max payload size exceeded\"), null);\n    });\n  }\n}\nfunction ve(i) {\n  this[M][R](i);\n}\nfunction be(i) {\n  this[g] += i.length, this[w].push(i);\n}\nfunction xe(i) {\n  this[M][R](i);\n}\nfunction Le(i) {\n  this[g] += i.length, this[w].push(i);\n}\nfunction Te(i) {\n  return i >= 1e3 && i <= 1014 && i !== 1004 && i !== 1005 && i !== 1006 || i >= 3e3 && i <= 4999;\n}\nfunction H(i) {\n  const e = i.length;\n  let t = 0;\n  for (; t < e; )\n    if (!(i[t] & 128))\n      t++;\n    else if ((i[t] & 224) === 192) {\n      if (t + 1 === e || (i[t + 1] & 192) !== 128 || (i[t] & 254) === 192)\n        return !1;\n      t += 2;\n    } else if ((i[t] & 240) === 224) {\n      if (t + 2 >= e || (i[t + 1] & 192) !== 128 || (i[t + 2] & 192) !== 128 || i[t] === 224 && (i[t + 1] & 224) === 128 || // Overlong\n      i[t] === 237 && (i[t + 1] & 224) === 160)\n        return !1;\n      t += 3;\n    } else if ((i[t] & 248) === 240) {\n      if (t + 3 >= e || (i[t + 1] & 192) !== 128 || (i[t + 2] & 192) !== 128 || (i[t + 3] & 192) !== 128 || i[t] === 240 && (i[t + 1] & 240) === 128 || // Overlong\n      i[t] === 244 && i[t + 1] > 143 || i[t] > 244)\n        return !1;\n      t += 4;\n    } else\n      return !1;\n  return !0;\n}\nconst V = U ? function(i) {\n  return i.length < 24 ? H(i) : U(i);\n} : H;\nvar $;\nconst x = Buffer[Symbol.species], _ = 0, G = 1, z = 2, j = 3, P = 4, N = 5, L = 6;\nclass Y extends ($ = ce, $) {\n  constructor(e = {}) {\n    super(), this._allowSynchronousEvents = e.allowSynchronousEvents !== void 0 ? e.allowSynchronousEvents : !0, this._binaryType = e.binaryType || A[0], this._extensions = e.extensions || {}, this._isServer = !!e.isServer, this._maxPayload = e.maxPayload || 0, this._skipUTF8Validation = !!e.skipUTF8Validation, this[me] = void 0, this._bufferedBytes = 0, this._buffers = [], this._compressed = !1, this._payloadLength = 0, this._mask = void 0, this._fragmented = 0, this._masked = !1, this._fin = !1, this._opcode = 0, this._totalPayloadLength = 0, this._messageLength = 0, this._fragments = [], this._errored = !1, this._loop = !1, this._state = _;\n  }\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {string} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(e, t, r) {\n    if (this._opcode === 8 && this._state === _) return r();\n    this._bufferedBytes += e.length, this._buffers.push(e), this.startLoop(r);\n  }\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(e) {\n    if (this._bufferedBytes -= e, e === this._buffers[0].length) return this._buffers.shift();\n    if (e < this._buffers[0].length) {\n      const r = this._buffers[0];\n      return this._buffers[0] = new x(r.buffer, r.byteOffset + e, r.length - e), new x(r.buffer, r.byteOffset, e);\n    }\n    const t = Buffer.allocUnsafe(e);\n    do {\n      const r = this._buffers[0], s = t.length - e;\n      e >= r.length ? t.set(this._buffers.shift(), s) : (t.set(new Uint8Array(r.buffer, r.byteOffset, e), s), this._buffers[0] = new x(r.buffer, r.byteOffset + e, r.length - e)), e -= r.length;\n    } while (e > 0);\n    return t;\n  }\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(e) {\n    this._loop = !0;\n    do\n      switch (this._state) {\n        case _:\n          this.getInfo(e);\n          break;\n        case G:\n          this.getPayloadLength16(e);\n          break;\n        case z:\n          this.getPayloadLength64(e);\n          break;\n        case j:\n          this.getMask();\n          break;\n        case P:\n          this.getData(e);\n          break;\n        case N:\n        case L:\n          this._loop = !1;\n          return;\n      }\n    while (this._loop);\n    this._errored || e();\n  }\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(e) {\n    if (this._bufferedBytes < 2) {\n      this._loop = !1;\n      return;\n    }\n    const t = this.consume(2);\n    if (t[0] & 48) {\n      const s = this.createError(\n        RangeError,\n        \"RSV2 and RSV3 must be clear\",\n        !0,\n        1002,\n        \"WS_ERR_UNEXPECTED_RSV_2_3\"\n      );\n      e(s);\n      return;\n    }\n    const r = (t[0] & 64) === 64;\n    if (r && !this._extensions[q.extensionName]) {\n      const s = this.createError(\n        RangeError,\n        \"RSV1 must be clear\",\n        !0,\n        1002,\n        \"WS_ERR_UNEXPECTED_RSV_1\"\n      );\n      e(s);\n      return;\n    }\n    if (this._fin = (t[0] & 128) === 128, this._opcode = t[0] & 15, this._payloadLength = t[1] & 127, this._opcode === 0) {\n      if (r) {\n        const s = this.createError(\n          RangeError,\n          \"RSV1 must be clear\",\n          !0,\n          1002,\n          \"WS_ERR_UNEXPECTED_RSV_1\"\n        );\n        e(s);\n        return;\n      }\n      if (!this._fragmented) {\n        const s = this.createError(\n          RangeError,\n          \"invalid opcode 0\",\n          !0,\n          1002,\n          \"WS_ERR_INVALID_OPCODE\"\n        );\n        e(s);\n        return;\n      }\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 1 || this._opcode === 2) {\n      if (this._fragmented) {\n        const s = this.createError(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          !0,\n          1002,\n          \"WS_ERR_INVALID_OPCODE\"\n        );\n        e(s);\n        return;\n      }\n      this._compressed = r;\n    } else if (this._opcode > 7 && this._opcode < 11) {\n      if (!this._fin) {\n        const s = this.createError(\n          RangeError,\n          \"FIN must be set\",\n          !0,\n          1002,\n          \"WS_ERR_EXPECTED_FIN\"\n        );\n        e(s);\n        return;\n      }\n      if (r) {\n        const s = this.createError(\n          RangeError,\n          \"RSV1 must be clear\",\n          !0,\n          1002,\n          \"WS_ERR_UNEXPECTED_RSV_1\"\n        );\n        e(s);\n        return;\n      }\n      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {\n        const s = this.createError(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          !0,\n          1002,\n          \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\"\n        );\n        e(s);\n        return;\n      }\n    } else {\n      const s = this.createError(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        !0,\n        1002,\n        \"WS_ERR_INVALID_OPCODE\"\n      );\n      e(s);\n      return;\n    }\n    if (!this._fin && !this._fragmented && (this._fragmented = this._opcode), this._masked = (t[1] & 128) === 128, this._isServer) {\n      if (!this._masked) {\n        const s = this.createError(\n          RangeError,\n          \"MASK must be set\",\n          !0,\n          1002,\n          \"WS_ERR_EXPECTED_MASK\"\n        );\n        e(s);\n        return;\n      }\n    } else if (this._masked) {\n      const s = this.createError(\n        RangeError,\n        \"MASK must be clear\",\n        !0,\n        1002,\n        \"WS_ERR_UNEXPECTED_MASK\"\n      );\n      e(s);\n      return;\n    }\n    this._payloadLength === 126 ? this._state = G : this._payloadLength === 127 ? this._state = z : this.haveLength(e);\n  }\n  /**\n   * Reads the next two bytes and stores the message length.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(e) {\n    if (this._bufferedBytes < 2) {\n      this._loop = !1;\n      return;\n    }\n    this._payloadLength = this.consume(2).readUInt16BE(0), this.haveLength(e);\n  }\n  /**\n   * Reads the next eight bytes and stores the message length.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(e) {\n    if (this._bufferedBytes < 8) {\n      this._loop = !1;\n      return;\n    }\n    const t = this.consume(8), r = t.readUInt32BE(0);\n    if (r > Math.pow(2, 21) - 1) {\n      const s = this.createError(\n        RangeError,\n        \"Unsupported WebSocket frame: payload length > 2^53 - 1\",\n        !1,\n        1009,\n        \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\"\n      );\n      e(s);\n      return;\n    }\n    this._payloadLength = r * Math.pow(2, 32) + t.readUInt32BE(4), this.haveLength(e);\n  }\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(e) {\n    if (this._payloadLength && this._opcode < 8 && (this._totalPayloadLength += this._payloadLength, this._totalPayloadLength > this._maxPayload && this._maxPayload > 0)) {\n      const t = this.createError(\n        RangeError,\n        \"Max payload size exceeded\",\n        !1,\n        1009,\n        \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n      );\n      e(t);\n      return;\n    }\n    this._masked ? this._state = j : this._state = P;\n  }\n  /**\n   * Reads the mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = !1;\n      return;\n    }\n    this._mask = this.consume(4), this._state = P;\n  }\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(e) {\n    let t = I;\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = !1;\n        return;\n      }\n      t = this.consume(this._payloadLength), this._masked && this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3] && we(t, this._mask);\n    }\n    if (this._opcode > 7) {\n      this.controlMessage(t, e);\n      return;\n    }\n    if (this._compressed) {\n      this._state = N, this.decompress(t, e);\n      return;\n    }\n    t.length && (this._messageLength = this._totalPayloadLength, this._fragments.push(t)), this.dataMessage(e);\n  }\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(e, t) {\n    this._extensions[q.extensionName].decompress(e, this._fin, (s, n) => {\n      if (s) return t(s);\n      if (n && n.length) {\n        if (this._messageLength += n.length, this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const o = this.createError(\n            RangeError,\n            \"Max payload size exceeded\",\n            !1,\n            1009,\n            \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n          );\n          t(o);\n          return;\n        }\n        this._fragments.push(n);\n      }\n      this.dataMessage(t), this._state === _ && this.startLoop(t);\n    });\n  }\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(e) {\n    if (!this._fin) {\n      this._state = _;\n      return;\n    }\n    const t = this._messageLength, r = this._fragments;\n    if (this._totalPayloadLength = 0, this._messageLength = 0, this._fragmented = 0, this._fragments = [], this._opcode === 2) {\n      let s;\n      this._binaryType === \"nodebuffer\" ? s = E(r, t) : this._binaryType === \"arraybuffer\" ? s = ye(E(r, t)) : this._binaryType === \"blob\" ? s = new Blob(r) : s = r, this._allowSynchronousEvents ? (this.emit(\"message\", s, !0), this._state = _) : (this._state = L, setImmediate(() => {\n        this.emit(\"message\", s, !0), this._state = _, this.startLoop(e);\n      }));\n    } else {\n      const s = E(r, t);\n      if (!this._skipUTF8Validation && !V(s)) {\n        const n = this.createError(\n          Error,\n          \"invalid UTF-8 sequence\",\n          !0,\n          1007,\n          \"WS_ERR_INVALID_UTF8\"\n        );\n        e(n);\n        return;\n      }\n      this._state === N || this._allowSynchronousEvents ? (this.emit(\"message\", s, !1), this._state = _) : (this._state = L, setImmediate(() => {\n        this.emit(\"message\", s, !1), this._state = _, this.startLoop(e);\n      }));\n    }\n  }\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(e, t) {\n    if (this._opcode === 8) {\n      if (e.length === 0)\n        this._loop = !1, this.emit(\"conclude\", 1005, I), this.end();\n      else {\n        const r = e.readUInt16BE(0);\n        if (!Te(r)) {\n          const n = this.createError(\n            RangeError,\n            `invalid status code ${r}`,\n            !0,\n            1002,\n            \"WS_ERR_INVALID_CLOSE_CODE\"\n          );\n          t(n);\n          return;\n        }\n        const s = new x(e.buffer, e.byteOffset + 2, e.length - 2);\n        if (!this._skipUTF8Validation && !V(s)) {\n          const n = this.createError(\n            Error,\n            \"invalid UTF-8 sequence\",\n            !0,\n            1007,\n            \"WS_ERR_INVALID_UTF8\"\n          );\n          t(n);\n          return;\n        }\n        this._loop = !1, this.emit(\"conclude\", r, s), this.end();\n      }\n      this._state = _;\n      return;\n    }\n    this._allowSynchronousEvents ? (this.emit(this._opcode === 9 ? \"ping\" : \"pong\", e), this._state = _) : (this._state = L, setImmediate(() => {\n      this.emit(this._opcode === 9 ? \"ping\" : \"pong\", e), this._state = _, this.startLoop(t);\n    }));\n  }\n  createError(e, t, r, s, n) {\n    this._loop = !1, this._errored = !0;\n    const o = new e(r ? `Invalid WebSocket frame: ${t}` : t);\n    return Error.captureStackTrace(o, this.createError), o.code = n, o[pe] = s, o;\n  }\n}\nfunction X(i, e, t) {\n  const r = i.write;\n  return i.write = (s) => {\n    try {\n      e.requestData = JSON.parse(s.toString());\n    } catch {\n      e.requestData = s;\n    }\n    return r.bind(i)(s);\n  }, i.on(\"error\", () => {\n    e.responseStatusCode = 0, e.requestEndTime = (/* @__PURE__ */ new Date()).getTime(), t.sendRequest(\"endRequest\", e);\n  }), e.isWebSocket() ? i.on(\"upgrade\", async (s, n, o) => {\n    const f = n.write;\n    if (e.isHiden())\n      return;\n    await t.send({\n      type: \"Network.webSocketCreated\",\n      data: {\n        requestId: e.id,\n        url: e.url,\n        initiator: e.initiator,\n        response: s\n      }\n    });\n    const a = new Y({\n      allowSynchronousEvents: !0,\n      binaryType: A[0],\n      isServer: !1\n    }), c = new Y({\n      allowSynchronousEvents: !0,\n      binaryType: A[0],\n      isServer: !0\n    }), h = (d) => {\n      const p = d.toString();\n      t.send({\n        type: \"Network.webSocketFrameReceived\",\n        data: {\n          requestId: e.id,\n          response: {\n            payloadData: p,\n            opcode: 1,\n            mask: !1\n          }\n        }\n      });\n    }, m = (d) => {\n      const p = d.toString();\n      t.send({\n        type: \"Network.webSocketFrameSent\",\n        data: {\n          requestId: e.id,\n          response: {\n            payloadData: p,\n            opcode: 1,\n            mask: !0\n          }\n        }\n      });\n    };\n    a.on(\"message\", h), c.on(\"message\", m);\n    let l;\n    n.write = (d, ...p) => {\n      const u = Buffer.from(d);\n      return c.write(u), f.call(n, d, ...p);\n    }, n.addListener(\"data\", (d) => {\n      const p = Buffer.from(d);\n      a.write(p);\n    }), n.addListener(\"close\", () => {\n      l = n.read(), l !== null && (a.write(l), c.write(l)), a.end(), c.end(), a.removeAllListeners(), c.removeAllListeners(), t.send({\n        method: \"Network.webSocketClosed\",\n        params: {\n          requestId: e.id,\n          timestamp: ne()\n        }\n      });\n    }), n.addListener(\"end\", () => {\n      a.end(), c.end(), a.removeAllListeners(), c.removeAllListeners();\n    });\n  }) : t.sendRequest(\"registerRequest\", e), i;\n}\nfunction ke(i, e, t) {\n  return (r) => {\n    e.responseHeaders = r.headers, typeof i == \"function\" && i(r), t.responseRequest(e.id, r);\n  };\n}\nfunction J(i, e) {\n  let t = i.setHeader;\n  i.setHeader = function(r, s) {\n    return Array.isArray(s) ? s.forEach((n) => {\n      e.requestHeaders[r] = n;\n    }) : e.requestHeaders[r] = s, t.call(i, r, s);\n  };\n}\nfunction Pe(i, e, t) {\n  return (s, n, o) => {\n    let f, a, c;\n    typeof s == \"string\" || s instanceof URL ? (f = s, a = n, c = o) : (a = s, c = n);\n    const h = new Q();\n    if (typeof f == \"string\")\n      h.url = f, h.method = \"GET\";\n    else if (f instanceof URL)\n      h.url = f.toString(), h.method = \"GET\";\n    else if (a && typeof a != \"string\" && !(a instanceof URL)) {\n      const l = e ? \"https\" : \"http\";\n      h.url = `${l}://${a.hostname || a.host}${a.path}`;\n    }\n    a && typeof a != \"string\" && !(a instanceof URL) && (h.method = a.method, h.requestHeaders = a.headers), h.loadCallFrames(), h.isWebSocket() && (h.url = h.url.replace(\"http://\", \"ws://\").replace(\"https://\", \"wss://\")), t.sendRequest(\"initRequest\", h);\n    const m = ke(c, h, t);\n    if (typeof s == \"string\" || s instanceof URL) {\n      const l = i(\n        f,\n        a,\n        m\n      );\n      return J(l, h), X(l, h, t);\n    } else {\n      const l = i(a, m);\n      return J(l, h), X(l, h, t);\n    }\n  };\n}\nconst Ne = (i) => new Promise((e) => setTimeout(e, i)), Be = (i, e) => {\n  try {\n    return Number(i) === process.pid ? Promise.resolve(!0) : (process.kill(Number(i), 0), new Promise((t) => {\n      const r = de.createServer();\n      r.once(\"error\", (s) => {\n        s.code === \"EADDRINUSE\" && t(!1), t(!1);\n      }), r.once(\"listening\", () => {\n        r.close(() => t(!0));\n      }), r.listen(e);\n    }));\n  } catch {\n    return Promise.resolve(!1);\n  }\n}, B = (i) => {\n  try {\n    T.unlinkSync(i);\n  } catch {\n  }\n};\nlet te = null;\nfunction S() {\n  return te;\n}\nfunction K(i) {\n  te = i;\n}\nclass Z extends Error {\n  constructor(e) {\n    super(e);\n  }\n}\nclass Ae {\n  constructor(e) {\n    this.options = e, this.ws = new Promise(async (t, r) => {\n      const s = F(O, `./${e.key}`);\n      if (T.existsSync(s)) {\n        const o = T.readFileSync(s, \"utf-8\");\n        if (await Ne(1), await Be(o, e.port)) {\n          oe(\"The main process with same options is already running, skip it.\");\n          return;\n        }\n        B(s);\n      }\n      T.writeFileSync(s, `${process.pid}`);\n      const n = new C(`ws://localhost:${e.port}`);\n      n.on(\"open\", () => {\n        B(s), t(n);\n      }), n.on(\"error\", () => {\n        this.openProcess(() => {\n          B(s);\n          const o = new C(`ws://localhost:${e.port}`);\n          o.on(\"open\", () => {\n            t(o);\n          }), o.on(\"error\", r);\n        });\n      });\n    }), this.ws.then((t) => {\n      this.healthCheck(), t.on(\"error\", (r) => {\n        console.error(\"MainProcess Socket Error: \", r);\n      });\n    }).catch((t) => {\n      if (!(t instanceof Z))\n        throw t;\n    });\n  }\n  openProcess(e) {\n    (() => {\n      const r = _e(F(O, \"./fork\"), {\n        env: {\n          ...process.env,\n          NETWORK_OPTIONS: JSON.stringify(this.options)\n        }\n      }), s = (n) => {\n        n === ae && (e && e(r), r.off(\"message\", s));\n      };\n      r.on(\"message\", s), this.cp = r;\n    })();\n  }\n  async send(e) {\n    if (S()?.isAborted)\n      return;\n    const r = await this.ws.catch((s) => {\n      if (s instanceof Z)\n        return null;\n      throw s;\n    });\n    r && r.send(JSON.stringify(e));\n  }\n  sendRequest(e, t) {\n    const r = S();\n    let s = t;\n    return r && (r.request = s, r.pipes.filter((o) => o.type === e).map((o) => o.pipe).forEach((o) => {\n      s = o(s);\n    }), r.request = s), this.send({\n      type: e,\n      data: t\n    }), this;\n  }\n  async healthCheck() {\n    const e = await this.ws, t = () => {\n      e.send(\n        JSON.stringify({\n          type: \"healthcheck\",\n          data: {}\n        })\n      );\n    };\n    t(), setInterval(t, 2e3);\n  }\n  responseRequest(e, t) {\n    const r = [];\n    t.on(\"data\", (s) => {\n      r.push(s);\n    }), t.on(\"end\", () => {\n      const s = Buffer.concat(r);\n      this.ws.then((n) => {\n        n.send(\n          JSON.stringify({\n            type: \"responseData\",\n            data: {\n              id: e,\n              rawData: s,\n              statusCode: t.statusCode,\n              headers: t.headers\n            }\n          }),\n          { binary: !0 }\n        );\n      });\n    });\n  }\n  async dispose() {\n    const e = await this.ws;\n    e.removeAllListeners(), e.terminate(), this.cp && (this.cp.removeAllListeners(), this.cp.kill(), this.cp = void 0);\n  }\n}\nfunction Ie(i) {\n  if (!globalThis.fetch)\n    return;\n  const e = globalThis.fetch;\n  return globalThis.fetch = se(e, i), () => {\n    globalThis.fetch = e;\n  };\n}\nfunction se(i, e) {\n  return function(t, r) {\n    const s = new Q();\n    s.requestStartTime = Date.now(), K({ request: s, pipes: [], isAborted: !1 }), typeof t == \"string\" ? s.url = t : t instanceof URL && (s.url = t.toString()), s.method = r?.method ?? \"GET\";\n    const n = r?.headers;\n    if (n instanceof Headers) {\n      const f = ee(n);\n      s.requestHeaders = f;\n    } else\n      s.requestHeaders = n ?? {};\n    s.requestData = r?.body;\n    const o = i(t, r).then(Me(s, e)).catch(We(s, e)).finally(() => {\n      K(null);\n    });\n    return e.sendRequest(\"initRequest\", s).sendRequest(\"registerRequest\", s), o;\n  };\n}\nfunction Me(i, e) {\n  return (t) => (i.requestEndTime = (/* @__PURE__ */ new Date()).getTime(), i.responseHeaders = ee(t.headers), i.responseStatusCode = t.status || 0, t.clone().arrayBuffer().then((r) => {\n    const s = Buffer.from(r);\n    i.responseData = s, i.responseInfo.dataLength = s.length, i.responseInfo.encodedDataLength = s.length;\n  }).finally(() => {\n    e.sendRequest(\"updateRequest\", i).sendRequest(\"endRequest\", i);\n  }), t);\n}\nfunction We(i, e) {\n  return (t) => {\n    throw i.requestEndTime = Date.now(), i.responseStatusCode = 0, e.sendRequest(\"updateRequest\", i).sendRequest(\"endRequest\", i), t;\n  };\n}\nconst Oe = (i) => {\n  if (!v.fetch)\n    return;\n  const e = v.fetch;\n  return v.fetch = se(\n    e,\n    i\n  ), () => {\n    v.fetch = e;\n  };\n}, Xe = (i) => {\n  const e = S();\n  if (!e)\n    throw new Error(\"useRegisterRequest must be used in request handler\");\n  e.pipes.push({\n    pipe: i,\n    type: \"registerRequest\"\n  });\n}, Je = (i, e) => {\n  const t = S();\n  if (!t)\n    throw new Error(\"useRequestPipe must be used in request handler\");\n  t.pipes.push({\n    pipe: e,\n    type: i\n  });\n}, Ke = () => {\n  const i = S();\n  if (!i)\n    throw new Error(\"useRegisterRequest must be used in request handler\");\n  i.isAborted = !0;\n};\nfunction Ze(i) {\n  const {\n    port: e = le,\n    serverPort: t = fe,\n    autoOpenDevtool: r = !0,\n    intercept: s = {}\n  } = i || {}, {\n    fetch: n = !0,\n    normal: o = !0,\n    undici: f = !1\n  } = s, a = f && f.fetch, c = he(JSON.stringify({ port: e, serverPort: t, autoOpenDevtool: r })), h = new Ae({\n    port: e,\n    serverPort: t,\n    autoOpenDevtool: r,\n    key: c\n  }), m = n ? Ie(h) : void 0, l = /* @__PURE__ */ new WeakMap(), d = [ie, W];\n  o && d.forEach((u) => {\n    l.set(u, u.request);\n    const re = u.request;\n    u.request = Pe(re, u === W, h);\n  });\n  const p = a ? Oe(h) : void 0;\n  return () => {\n    m && m(), o && d.forEach((u) => {\n      u.request = l.get(u), l.delete(u);\n    }), p && p(), h.dispose();\n  };\n}\nexport {\n  S as getCurrentCell,\n  Ze as register,\n  K as setCurrentCell,\n  Ke as useAbortRequest,\n  Xe as useRegisterRequest,\n  Je as useRequestPipe\n};\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"mappings":"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"}