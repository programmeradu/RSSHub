{"version":3,"file":"getitfree-tAwZ8YLG.js","names":["filterPairs","key","filters","rootUrl","response","got","filterStr","route: Route","got"],"sources":["../../lib/routes/getitfree/util.ts","../../lib/routes/getitfree/index.ts"],"sourcesContent":["import got from '@/utils/got';\r\nimport { load } from 'cheerio';\r\n\r\nconst rootUrl = 'https://getitfree.cn';\r\nconst apiSlug = 'wp-json/wp/v2';\r\n\r\nconst filterKeys = {\r\n    search: 's',\r\n};\r\n\r\nconst filterApiKeys = {\r\n    category: 'categories',\r\n    tag: 'tags',\r\n    search: undefined,\r\n};\r\n\r\nconst filterApiKeysWithNoId = new Set(['search']);\r\n\r\n/**\r\n * Bake filter search parameters.\r\n *\r\n * @param {Object} filterPairs - The filter pairs object.\r\n *                               e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n * @param {string} pairKey - The filter pair key.\r\n *                           e.g. `{ id: ..., name: ..., slug: ... }`.\r\n * @param {boolean} [isApi=false] - IIndicates if the search parameters are for API.\r\n * @returns {URLSearchParams} The baked filter search parameters.\r\n */\r\nconst bakeFilterSearchParams = (filterPairs, pairKey, isApi = false) => {\r\n    /**\r\n     * Bake filters recursively.\r\n     *\r\n     * @param {Object} filterPairs - The filter pairs object.\r\n     *                               e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n     * @param {URLSearchParams} filterSearchParams - The filter search parameters.\r\n     *                                               e.g. `category=a,b&tag=c`.\r\n     * @returns {URLSearchParams} The baked filter search parameters.\r\n     *                            e.g. `category=a,b&tag=c`.\r\n     */\r\n    const bakeFilters = (filterPairs, filterSearchParams) => {\r\n        const keys = Object.keys(filterPairs).filter((key) => filterPairs[key]?.length > 0 && (isApi ? Object.hasOwn(filterApiKeys, key) : Object.hasOwn(filterKeys, key)));\r\n\r\n        if (keys.length === 0) {\r\n            return filterSearchParams;\r\n        }\r\n\r\n        const key = keys[0];\r\n        const pairs = filterPairs[key];\r\n\r\n        const originalFilters = Object.assign({}, filterPairs);\r\n        delete originalFilters[key];\r\n\r\n        filterSearchParams.append(getFilterKeyForSearchParams(key, isApi), pairs.map((pair) => (Object.hasOwn(pair, pairKey) ? pair[pairKey] : pair)).join(','));\r\n\r\n        return bakeFilters(originalFilters, filterSearchParams);\r\n    };\r\n\r\n    return bakeFilters(filterPairs, new URLSearchParams());\r\n};\r\n\r\n/**\r\n * Bake filters with pair.\r\n *\r\n * @param {Object} filters - The filters object.\r\n *                           e.g. `{ category: [ a, b ], tag: [ c ] }`.\r\n * @returns {Promise<Object>} The baked filters.\r\n *                            e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n */\r\nconst bakeFiltersWithPair = async (filters) => {\r\n    /**\r\n     * Bake keywords recursively.\r\n     *\r\n     * @param {string} key - The key.\r\n     *                       e.g. `category` or `tag`.\r\n     * @param {Array<string>} keywords - The keywords.\r\n     *                                   e.g. `[ a, b ]`.\r\n     * @returns {Promise<Array<Object>>} The baked keywords.\r\n     *                                   e.g. `[ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ]`.\r\n     */\r\n    const bakeKeywords = async (key, keywords) => {\r\n        if (keywords.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        const [keyword, ...rest] = keywords;\r\n\r\n        const filter = await getFilterByKeyAndKeyword(key, keyword);\r\n\r\n        return [\r\n            ...(filter?.id && filter?.slug\r\n                ? [\r\n                      {\r\n                          id: filter.id,\r\n                          name: filter.name,\r\n                          slug: filter.slug,\r\n                      },\r\n                  ]\r\n                : []),\r\n            ...(await bakeKeywords(key, rest)),\r\n        ];\r\n    };\r\n\r\n    /**\r\n     * Bake filters recursively.\r\n     *\r\n     * @param {Object} filters - The filters object.\r\n     *                           e.g. `{ category: [ a, b ], tag: [ c ] }`.\r\n     * @param {Object} filtersWithPair - The filters with pairs.\r\n     *                                   e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n     * @returns {Promise<Object>} The baked filters.\r\n     *                            e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n     */\r\n    const bakeFilters = async (filters, filtersWithPair) => {\r\n        const keys = Object.keys(filters);\r\n\r\n        if (keys.length === 0) {\r\n            return filtersWithPair;\r\n        }\r\n\r\n        const key = keys[0];\r\n        const keywords = filters[key];\r\n\r\n        const originalFilters = Object.assign({}, filters);\r\n        delete originalFilters[key];\r\n\r\n        return bakeFilters(originalFilters, {\r\n            ...filtersWithPair,\r\n            [key]: filterApiKeysWithNoId.has(key) ? keywords : await bakeKeywords(key, keywords),\r\n        });\r\n    };\r\n\r\n    return await bakeFilters(filters, {});\r\n};\r\n\r\n/**\r\n * Bake URL with search parameters.\r\n *\r\n * @param {string} url - The URL.\r\n * @param {string} rootUrl - The root URL.\r\n * @param {URLSearchParams} [searchParams=new URLSearchParams()] - The search parameters.\r\n * @returns {string} The baked URL.\r\n */\r\nconst bakeUrl = (url, rootUrl, searchParams = new URLSearchParams()) => {\r\n    const searchParamsStr = String(searchParams) ? `?${searchParams}` : '';\r\n\r\n    return new URL(`${url}${searchParamsStr}`, rootUrl).href;\r\n};\r\n\r\n/**\r\n * Fetch data from the specified URL.\r\n *\r\n * @param {string} url - The URL to fetch data from.\r\n * @returns {Promise<Object>} A promise that resolves to an object containing the fetched data\r\n *                            to be added into `ctx.state.data`.\r\n */\r\nconst fetchData = async (url) => {\r\n    /**\r\n     * Request URLs recursively.\r\n     *\r\n     * @param {Array<string>} urls - The URLs to request.\r\n     * @returns {Promise<undefined|Object>} A promise that resolves to the response data\r\n     *                                      or undefined if no response is available.\r\n     */\r\n    const requestUrls = async (urls) => {\r\n        if (urls.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const [currentUrl, ...remainingUrls] = urls;\r\n        try {\r\n            const { data: response } = await got(currentUrl);\r\n            return response;\r\n        } catch {\r\n            return requestUrls(remainingUrls);\r\n        }\r\n    };\r\n\r\n    const response = await requestUrls([url, rootUrl]);\r\n\r\n    if (!response) {\r\n        return {};\r\n    }\r\n\r\n    const $ = load(response);\r\n\r\n    const title = $('title').text().split(/\\|/)[0];\r\n    const image = new URL('wp-content/uploads/site_logo.png', rootUrl).href;\r\n    const icon = new URL($('link[rel=\"shortcut icon\"]').prop('href'), rootUrl).href;\r\n\r\n    return {\r\n        title,\r\n        link: url,\r\n        description: $('meta[name=\"description\"]').prop('content'),\r\n        language: $('html').prop('lang'),\r\n        image,\r\n        icon,\r\n        logo: icon,\r\n        subtitle: title.split(/„Äê/)[0],\r\n        author: $('h1.logo a').prop('title'),\r\n        allowEmpty: true,\r\n    };\r\n};\r\n\r\n/**\r\n * Get filter by key and keyword.\r\n *\r\n * @param {string} key - The key.\r\n *                       e.g. `category` or `tag`.\r\n * @param {string} keyword - The keywords.\r\n *                           e.g. `keyword1`.\r\n * @returns {Promise<Object|undefined>} A promise that resolves to the filter object if found,\r\n *                                      or undefined if not found.\r\n */\r\nconst getFilterByKeyAndKeyword = async (key, keyword) => {\r\n    const apiFilterUrl = new URL(`${apiSlug}/${getFilterKeyForSearchParams(key, true)}`, rootUrl).href;\r\n\r\n    const { data: response } = await got(apiFilterUrl, {\r\n        searchParams: {\r\n            search: keyword,\r\n        },\r\n    });\r\n\r\n    return response.length > 0 ? response[0] : undefined;\r\n};\r\n\r\n/**\r\n * Get filter key for search parameters.\r\n *\r\n * @param {string} key - The key. e.g. `category` or `tag`.\r\n * @param {boolean} [isApi=false] - Indicates whether the key is for the API.\r\n * @returns {string|undefined} The filter key for search parameters, or undefined if not found.\r\n *                             e.g. `categories` or `tags`.\r\n */\r\nconst getFilterKeyForSearchParams = (key, isApi = false) => {\r\n    const keys = isApi ? filterApiKeys : filterKeys;\r\n\r\n    return Object.hasOwn(keys, key) ? (keys[key] ?? key) : undefined;\r\n};\r\n\r\n/**\r\n * Get filter names for titles.\r\n *\r\n * @param {Object} filterPairs - The filter pairs object.\r\n *                               e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n * @returns {string} A string containing the joined filter names for titles.\r\n *                   e.g. `name1,name2`.\r\n */\r\nconst getFilterNameForTitle = (filterPairs) =>\r\n    Object.values(filterPairs)\r\n        .flat()\r\n        .map((pair) => pair?.name ?? pair?.slug ?? pair)\r\n        .filter(Boolean)\r\n        .join(',');\r\n\r\n/**\r\n * Get filter parameters for URL.\r\n *\r\n * @param {Object} filterPairs - The filter pairs object.\r\n *                               e.g. `{ category: [ { id: ..., name: ..., slug: ... }, { id: ..., name: ..., slug: ... } ], tag: [ { id: ..., name: ..., slug: ... } ] }`.\r\n * @returns {string|undefined} The filter parameters for the URL, or undefined if no filters are available.\r\n */\r\nconst getFilterParamsForUrl = (filterPairs) => {\r\n    const keys = Object.keys(filterPairs).filter((key) => filterPairs[key]);\r\n\r\n    if (keys.length === 0) {\r\n        return;\r\n    }\r\n\r\n    const key = keys[0];\r\n\r\n    return `${key}/${filterPairs[key].map((pair) => pair.slug).join('/')}`;\r\n};\r\n\r\n/**\r\n * Parse filter string into filters object.\r\n *\r\n * @param {string} filterStr - The filter string to parse.\r\n *                             e.g. `category/a,b/tag/c`.\r\n * @returns {Object} The parsed filters object.\r\n *                   e.g. `{ category: [ a, b ], tag: [ c ] }`.\r\n */\r\nconst parseFilterStr = (filterStr) => {\r\n    /**\r\n     * Parse filter string recursively.\r\n     *\r\n     * @param {string} filterStr - The remaining filter string to parse.\r\n     *                             e.g. `category/a,b/tag/c`.\r\n     * @param {Object} filters - The accumulated filters object.\r\n     *                           e.g. `{ category: [ a, b ], tag: [ c ] }`.\r\n     * @param {string} filterKey - The current filter key.\r\n     *                             e.g. `category` or `tag`.\r\n     * @returns {Object} The parsed filters object.\r\n     */\r\n    const parseStr = (filterStr, filters = {}, filterKey) => {\r\n        if (!filterStr) {\r\n            return filters;\r\n        }\r\n\r\n        const [word, ...rest] = filterStr.split(/\\/|,/);\r\n\r\n        const isKey = Object.hasOwn(filterApiKeys, word);\r\n        const key = isKey ? word : filterKey;\r\n\r\n        const newFilters = {\r\n            ...filters,\r\n            [key]: [...(filters[key] || []), ...(isKey ? [] : [word])],\r\n        };\r\n\r\n        return parseStr(rest.join('/'), newFilters, key);\r\n    };\r\n\r\n    return parseStr(filterStr, {});\r\n};\r\n\r\nexport { apiSlug, rootUrl, bakeFilterSearchParams, bakeFiltersWithPair, bakeUrl, fetchData, getFilterNameForTitle, getFilterParamsForUrl, parseFilterStr };\r\n","import { Route } from '@/types';\r\nimport got from '@/utils/got';\r\nimport { load } from 'cheerio';\r\nimport { parseDate } from '@/utils/parse-date';\r\n\r\nimport { apiSlug, rootUrl, bakeFilterSearchParams, bakeFiltersWithPair, bakeUrl, fetchData, getFilterNameForTitle, getFilterParamsForUrl, parseFilterStr } from './util';\r\n\r\nexport const route: Route = {\r\n    path: '/:filter{.+}?',\r\n    name: 'Unknown',\r\n    maintainers: [],\r\n    handler,\r\n};\r\n\r\nasync function handler(ctx) {\r\n    const filter = ctx.req.param('filter');\r\n    const limit = ctx.req.query('limit') ? Number.parseInt(ctx.req.query('limit'), 10) : 50;\r\n\r\n    const filters = parseFilterStr(filter);\r\n    const filtersWithPair = await bakeFiltersWithPair(filters);\r\n\r\n    const searchParams = bakeFilterSearchParams(filters, 'name', false);\r\n    const apiSearchParams = bakeFilterSearchParams(filtersWithPair, 'id', true);\r\n\r\n    apiSearchParams.append('_embed', 'true');\r\n    apiSearchParams.append('per_page', limit);\r\n\r\n    const apiUrl = bakeUrl(`${apiSlug}/posts`, rootUrl, apiSearchParams);\r\n    const currentUrl = bakeUrl(getFilterParamsForUrl(filtersWithPair) ?? '', rootUrl, searchParams);\r\n\r\n    const { data: response } = await got(apiUrl);\r\n\r\n    const items = (Array.isArray(response) ? response : JSON.parse(response.match(/(\\[.*])$/)[1])).slice(0, limit).map((item) => {\r\n        const terminologies = item._embedded['wp:term'];\r\n\r\n        const content = load(item.content?.rendered ?? item.content);\r\n\r\n        content('div.mycred-sell-this-wrapper').prevUntil('hr').nextAll().remove();\r\n\r\n        return {\r\n            title: item.title?.rendered ?? item.title,\r\n            link: item.link,\r\n            description: content.html(),\r\n            author: item._embedded.author.map((a) => a.name).join('/'),\r\n            category: [...new Set(terminologies.flat().map((c) => c.name))],\r\n            guid: item.guid?.rendered ?? item.guid,\r\n            pubDate: parseDate(item.date_gmt),\r\n            updated: parseDate(item.modified_gmt),\r\n        };\r\n    });\r\n\r\n    const subtitle = getFilterNameForTitle(filtersWithPair);\r\n\r\n    return {\r\n        ...(await fetchData(currentUrl)),\r\n        item: items,\r\n        title: `Getitfree${subtitle ? ` | ${subtitle}` : ''}`,\r\n    };\r\n}\r\n"],"mappings":"oTAGA,MAAM,EAAU,uBACV,EAAU,gBAEV,EAAa,CACf,OAAQ,KAGN,EAAgB,CAClB,SAAU,aACV,IAAK,OACL,OAAQ,IAAA,IAGN,EAAwB,IAAI,IAAI,CAAC,WAYjC,GAA0B,EAAa,EAAS,EAAQ,KAAU,CAWpE,IAAM,GAAe,EAAa,IAAuB,CACrD,IAAM,EAAO,OAAO,KAAKA,GAAa,OAAQ,GAAQA,EAAYC,IAAM,OAAS,IAAM,EAAQ,OAAO,OAAO,EAAeA,GAAO,OAAO,OAAO,EAAYA,KAE7J,GAAI,EAAK,SAAW,EAChB,OAAO,EAGX,IAAM,EAAM,EAAK,GACX,EAAQD,EAAY,GAEpB,EAAkB,OAAO,OAAO,GAAIA,GAK1C,OAJA,OAAO,EAAgB,GAEvB,EAAmB,OAAO,EAA4B,EAAK,GAAQ,EAAM,IAAK,GAAU,OAAO,OAAO,EAAM,GAAW,EAAK,GAAW,GAAO,KAAK,MAE5I,EAAY,EAAiB,IAGxC,OAAO,EAAY,EAAa,IAAI,kBAWlC,EAAsB,KAAO,IAAY,CAW3C,IAAM,EAAe,MAAO,EAAK,IAAa,CAC1C,GAAI,EAAS,SAAW,EACpB,MAAO,GAGX,GAAM,CAAC,EAAS,GAAG,GAAQ,EAErB,EAAS,MAAM,EAAyB,EAAK,GAEnD,MAAO,CACH,GAAI,GAAQ,IAAM,GAAQ,KACpB,CACI,CACI,GAAI,EAAO,GACX,KAAM,EAAO,KACb,KAAM,EAAO,OAGrB,GACN,GAAI,MAAM,EAAa,EAAK,KAc9B,EAAc,MAAO,EAAS,IAAoB,CACpD,IAAM,EAAO,OAAO,KAAKE,GAEzB,GAAI,EAAK,SAAW,EAChB,OAAO,EAGX,IAAM,EAAM,EAAK,GACX,EAAWA,EAAQ,GAEnB,EAAkB,OAAO,OAAO,GAAIA,GAG1C,OAFA,OAAO,EAAgB,GAEhB,EAAY,EAAiB,CAChC,GAAG,GACF,GAAM,EAAsB,IAAI,GAAO,EAAW,MAAM,EAAa,EAAK,MAInF,OAAO,MAAM,EAAY,EAAS,KAWhC,GAAW,EAAK,EAAS,EAAe,IAAI,kBAAsB,CACpE,IAAM,EAAkB,OAAO,GAAgB,IAAI,IAAiB,GAEpE,OAAO,IAAI,IAAI,GAAG,IAAM,IAAmBC,GAAS,MAUlD,EAAY,KAAO,IAAQ,CAQ7B,IAAM,EAAc,KAAO,IAAS,CAChC,GAAI,EAAK,SAAW,EAChB,OAGJ,GAAM,CAAC,EAAY,GAAG,GAAiB,EACvC,GAAI,CACA,GAAM,CAAE,KAAMC,GAAa,MAAMI,EAAI,GACrC,OAAOJ,OACH,CACJ,OAAO,EAAY,KAIrB,EAAW,MAAM,EAAY,CAAC,EAAK,IAEzC,GAAI,CAAC,EACD,MAAO,GAGX,IAAM,EAAI,EAAK,GAET,EAAQ,EAAE,SAAS,OAAO,MAAM,MAAM,GACtC,EAAQ,IAAI,IAAI,mCAAoC,GAAS,KAC7D,EAAO,IAAI,IAAI,EAAE,6BAA6B,KAAK,QAAS,GAAS,KAE3E,MAAO,CACH,QACA,KAAM,EACN,YAAa,EAAE,4BAA4B,KAAK,WAChD,SAAU,EAAE,QAAQ,KAAK,QACzB,QACA,OACA,KAAM,EACN,SAAU,EAAM,MAAM,KAAK,GAC3B,OAAQ,EAAE,aAAa,KAAK,SAC5B,WAAY,KAcd,EAA2B,MAAO,EAAK,IAAY,CACrD,IAAM,EAAe,IAAI,IAAI,GAAG,EAAQ,GAAG,EAA4B,EAAK,MAAS,GAAS,KAExF,CAAE,KAAM,GAAa,MAAMI,EAAI,EAAc,CAC/C,aAAc,CACV,OAAQ,KAIhB,OAAO,EAAS,OAAS,EAAI,EAAS,GAAK,IAAA,IAWzC,GAA+B,EAAK,EAAQ,KAAU,CACxD,IAAM,EAAO,EAAQ,EAAgB,EAErC,OAAO,OAAO,OAAO,EAAM,GAAQ,EAAK,IAAQ,EAAO,IAAA,IAWrD,EAAyB,GAC3B,OAAO,OAAO,GACT,OACA,IAAK,GAAS,GAAM,MAAQ,GAAM,MAAQ,GAC1C,OAAO,SACP,KAAK,KASR,EAAyB,GAAgB,CAC3C,IAAM,EAAO,OAAO,KAAK,GAAa,OAAQ,GAAQ,EAAYP,IAElE,GAAI,EAAK,SAAW,EAChB,OAGJ,IAAM,EAAM,EAAK,GAEjB,MAAO,GAAG,EAAI,GAAG,EAAY,GAAK,IAAK,GAAS,EAAK,MAAM,KAAK,QAW9D,EAAkB,GAAc,CAYlC,IAAM,GAAY,EAAW,EAAU,GAAI,IAAc,CACrD,GAAI,CAACK,EACD,OAAO,EAGX,GAAM,CAAC,EAAM,GAAG,GAAQA,EAAU,MAAM,QAElC,EAAQ,OAAO,OAAO,EAAe,GACrC,EAAM,EAAQ,EAAO,EAErB,EAAa,CACf,GAAG,GACF,GAAM,CAAC,GAAI,EAAQ,IAAQ,GAAK,GAAI,EAAQ,GAAK,CAAC,KAGvD,OAAO,EAAS,EAAK,KAAK,KAAM,EAAY,IAGhD,OAAO,EAAS,EAAW,KChTlBC,EAAe,CACxB,KAAM,gBACN,KAAM,UACN,YAAa,GACb,WAGJ,eAAe,EAAQ,EAAK,CACxB,IAAM,EAAS,EAAI,IAAI,MAAM,UACvB,EAAQ,EAAI,IAAI,MAAM,SAAW,OAAO,SAAS,EAAI,IAAI,MAAM,SAAU,IAAM,GAE/E,EAAU,EAAe,GACzB,EAAkB,MAAM,EAAoB,GAE5C,EAAe,EAAuB,EAAS,OAAQ,IACvD,EAAkB,EAAuB,EAAiB,KAAM,IAEtE,EAAgB,OAAO,SAAU,QACjC,EAAgB,OAAO,WAAY,GAEnC,IAAM,EAAS,EAAQ,GAAG,EAAQ,QAAS,EAAS,GAC9C,EAAa,EAAQ,EAAsB,IAAoB,GAAI,EAAS,GAE5E,CAAE,KAAM,GAAa,MAAMC,EAAI,GAE/B,GAAS,MAAM,QAAQ,GAAY,EAAW,KAAK,MAAM,EAAS,MAAM,YAAY,KAAK,MAAM,EAAG,GAAO,IAAK,GAAS,CACzH,IAAM,EAAgB,EAAK,UAAU,WAE/B,EAAU,EAAK,EAAK,SAAS,UAAY,EAAK,SAIpD,OAFA,EAAQ,gCAAgC,UAAU,MAAM,UAAU,SAE3D,CACH,MAAO,EAAK,OAAO,UAAY,EAAK,MACpC,KAAM,EAAK,KACX,YAAa,EAAQ,OACrB,OAAQ,EAAK,UAAU,OAAO,IAAK,GAAM,EAAE,MAAM,KAAK,KACtD,SAAU,CAAC,GAAG,IAAI,IAAI,EAAc,OAAO,IAAK,GAAM,EAAE,QACxD,KAAM,EAAK,MAAM,UAAY,EAAK,KAClC,QAAS,EAAU,EAAK,UACxB,QAAS,EAAU,EAAK,iBAI1B,EAAW,EAAsB,GAEvC,MAAO,CACH,GAAI,MAAM,EAAU,GACpB,KAAM,EACN,MAAO,YAAY,EAAW,MAAM,IAAa"}