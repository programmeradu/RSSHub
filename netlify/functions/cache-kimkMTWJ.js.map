{"version":3,"file":"cache-kimkMTWJ.js","names":["status","clients: {\r\n    redisClient?: Redis;\r\n}","clients","clients: {\r\n    memoryCache?: LRUCache<any, any>;\r\n}","globalCache: {\r\n    get: (key: string) => Promise<string | null | undefined> | string | null | undefined;\r\n    set: (key: string, value?: string | Record<string, any>, maxAge?: number) => any;\r\n}","cacheModule: CacheModule","redis","memory"],"sources":["../../lib/utils/cache/redis.ts","../../lib/utils/cache/memory.ts","../../lib/utils/cache/index.ts"],"sourcesContent":["import { config } from '@/config';\r\nimport Redis from 'ioredis';\r\nimport logger from '@/utils/logger';\r\nimport type CacheModule from './base';\r\n\r\nconst status = { available: false };\r\nconst clients: {\r\n    redisClient?: Redis;\r\n} = {};\r\n\r\nconst getCacheTtlKey = (key: string) => {\r\n    if (key.startsWith('rsshub:cacheTtl:')) {\r\n        throw new Error('\"rsshub:cacheTtl:\" prefix is reserved for the internal usage, please change your cache key'); // blocking any attempt to get/set the cacheTtl\r\n    }\r\n    return `rsshub:cacheTtl:${key}`;\r\n};\r\n\r\nexport default {\r\n    init: () => {\r\n        clients.redisClient = new Redis(config.redis.url);\r\n\r\n        clients.redisClient.on('error', (error) => {\r\n            status.available = false;\r\n            logger.error('Redis error: ', error);\r\n        });\r\n        clients.redisClient.on('end', () => {\r\n            status.available = false;\r\n        });\r\n        clients.redisClient.on('connect', () => {\r\n            status.available = true;\r\n            logger.info('Redis connected.');\r\n        });\r\n    },\r\n    get: async (key: string, refresh = true) => {\r\n        if (key && status.available && clients.redisClient) {\r\n            const cacheTtlKey = getCacheTtlKey(key);\r\n            let [value, cacheTtl] = await clients.redisClient.mget(key, cacheTtlKey);\r\n            if (value && refresh) {\r\n                if (cacheTtl) {\r\n                    clients.redisClient.expire(cacheTtlKey, cacheTtl);\r\n                } else {\r\n                    // if cacheTtl is not set, that means the cache expire time is contentExpire\r\n                    cacheTtl = config.cache.contentExpire + '';\r\n                    // dont save cacheTtl to Redis, as it is the default value\r\n                    // redisClient.set(cacheTtlKey, cacheTtl, 'EX', cacheTtl);\r\n                }\r\n                clients.redisClient.expire(key, cacheTtl);\r\n                value = value + '';\r\n            }\r\n            return value || '';\r\n        } else {\r\n            return null;\r\n        }\r\n    },\r\n    set: (key: string, value?: string | Record<string, any>, maxAge = config.cache.contentExpire) => {\r\n        if (!status.available || !clients.redisClient) {\r\n            return;\r\n        }\r\n        if (!value || value === 'undefined') {\r\n            value = '';\r\n        }\r\n        if (typeof value === 'object') {\r\n            value = JSON.stringify(value);\r\n        }\r\n        if (key) {\r\n            if (maxAge !== config.cache.contentExpire) {\r\n                // intentionally store the cache ttl if it is not the default value\r\n                clients.redisClient.set(getCacheTtlKey(key), maxAge, 'EX', maxAge);\r\n            }\r\n            return clients.redisClient.set(key, value, 'EX', maxAge); // setMode: https://redis.io/commands/set\r\n        }\r\n    },\r\n    clients,\r\n    status,\r\n} as CacheModule;\r\n","import { LRUCache } from 'lru-cache';\r\nimport { config } from '@/config';\r\nimport type CacheModule from './base';\r\n\r\nconst status = { available: false };\r\nconst clients: {\r\n    memoryCache?: LRUCache<any, any>;\r\n} = {};\r\n\r\nexport default {\r\n    init: () => {\r\n        clients.memoryCache = new LRUCache({\r\n            ttl: config.cache.routeExpire * 1000,\r\n            max: config.memory.max,\r\n        });\r\n        status.available = true;\r\n    },\r\n    get: (key: string, refresh = true) => {\r\n        if (key && status.available && clients.memoryCache) {\r\n            let value = clients.memoryCache.get(key, { updateAgeOnGet: refresh }) as string | undefined;\r\n            if (value) {\r\n                value = value + '';\r\n            }\r\n            return value;\r\n        } else {\r\n            return null;\r\n        }\r\n    },\r\n    set: (key, value, maxAge = config.cache.contentExpire) => {\r\n        if (!value || value === 'undefined') {\r\n            value = '';\r\n        }\r\n        if (typeof value === 'object') {\r\n            value = JSON.stringify(value);\r\n        }\r\n        if (key && status.available && clients.memoryCache) {\r\n            return clients.memoryCache.set(key, value, { ttl: maxAge * 1000 });\r\n        }\r\n    },\r\n    clients,\r\n    status,\r\n} as CacheModule;\r\n","import { config } from '@/config';\r\nimport redis from './redis';\r\nimport memory from './memory';\r\nimport type CacheModule from './base';\r\nimport logger from '@/utils/logger';\r\n\r\nconst globalCache: {\r\n    get: (key: string) => Promise<string | null | undefined> | string | null | undefined;\r\n    set: (key: string, value?: string | Record<string, any>, maxAge?: number) => any;\r\n} = {\r\n    get: () => null,\r\n    set: () => null,\r\n};\r\n\r\nlet cacheModule: CacheModule;\r\n\r\nif (config.cache.type === 'redis') {\r\n    cacheModule = redis;\r\n    cacheModule.init();\r\n    const { redisClient } = cacheModule.clients;\r\n    globalCache.get = async (key) => {\r\n        if (key && cacheModule.status.available && redisClient) {\r\n            const value = await redisClient.get(key);\r\n            return value;\r\n        }\r\n    };\r\n    globalCache.set = cacheModule.set;\r\n} else if (config.cache.type === 'memory') {\r\n    cacheModule = memory;\r\n    cacheModule.init();\r\n    const { memoryCache } = cacheModule.clients;\r\n    globalCache.get = (key) => {\r\n        if (key && cacheModule.status.available && memoryCache) {\r\n            return memoryCache.get(key, { updateAgeOnGet: false }) as string | undefined;\r\n        }\r\n    };\r\n    globalCache.set = (key, value, maxAge = config.cache.routeExpire) => {\r\n        if (!value || value === 'undefined') {\r\n            value = '';\r\n        }\r\n        if (typeof value === 'object') {\r\n            value = JSON.stringify(value);\r\n        }\r\n        if (key && memoryCache) {\r\n            return memoryCache.set(key, value, { ttl: maxAge * 1000 });\r\n        }\r\n    };\r\n} else {\r\n    cacheModule = {\r\n        init: () => null,\r\n        get: () => null,\r\n        set: () => null,\r\n        status: {\r\n            available: false,\r\n        },\r\n        clients: {},\r\n    };\r\n    logger.error('Cache not available, concurrent requests are not limited. This could lead to bad behavior.');\r\n}\r\n\r\n// only give cache string, as the `!` condition tricky\r\n// md5 is used to shrink key size\r\n// plz, write these tips in comments!\r\nexport default {\r\n    ...cacheModule,\r\n    /**\r\n     * Try to get the cache. If the cache does not exist, the `getValueFunc` function will be called to get the data, and the data will be cached.\r\n     * @param key The key used to store and retrieve the cache. You can use `:` as a separator to create a hierarchy.\r\n     * @param getValueFunc A function that returns data to be cached when a cache miss occurs.\r\n     * @param maxAge The maximum age of the cache in seconds. This should left to the default value in most cases which is `CACHE_CONTENT_EXPIRE`.\r\n     * @param refresh Whether to renew the cache expiration time when the cache is hit. `true` by default.\r\n     * @returns\r\n     */\r\n    tryGet: async <T extends string | Record<string, any>>(key: string, getValueFunc: () => Promise<T>, maxAge = config.cache.contentExpire, refresh = true) => {\r\n        if (typeof key !== 'string') {\r\n            throw new TypeError('Cache key must be a string');\r\n        }\r\n        let v = await cacheModule.get(key, refresh);\r\n        if (v) {\r\n            let parsed;\r\n            try {\r\n                parsed = JSON.parse(v);\r\n            } catch {\r\n                parsed = null;\r\n            }\r\n            if (parsed) {\r\n                v = parsed;\r\n            }\r\n\r\n            return v as T;\r\n        } else {\r\n            const value = await getValueFunc();\r\n            cacheModule.set(key, value, maxAge);\r\n\r\n            return value;\r\n        }\r\n    },\r\n    globalCache,\r\n};\r\n"],"mappings":"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"}