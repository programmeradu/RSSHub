{"version":3,"file":"entry-CxjrDVBv.js","names":["route: Route","ConfigNotFoundError","result: Data","got","articles"],"sources":["../../lib/routes/miniflux/entry.ts"],"sourcesContent":["import { Route, Data } from '@/types';\r\nimport got from '@/utils/got';\r\nimport { config } from '@/config';\r\nimport ConfigNotFoundError from '@/errors/types/config-not-found';\r\n\r\nexport const route: Route = {\r\n    path: '/entry/:feeds/:parameters?',\r\n    description: `\r\n1. Support to get all content: You can obtain the content of all subscription sources by using keywords such as \\`/miniflux/all\\` or \\`/miniflux/default\\`.\r\n2. Support to get the subscription content of a specific subscription source by its ID. Please obtain the subscription source ID on the page where it is located under \\`Sources\\` (shortcut keys \\`g\\` \\`f\\`). The URL for each category (or subscription source) displays its ID information. There are several format options available:\r\n    1. Support \\`/miniflux/feed=[feed_id]\\`, please replace \\`[feed_id]\\` with the actual ID of the subscribed feed (note that it should be just a number without brackets).\r\n    2. Support subscribing to multiple feeds using \\`/miniflux/feed=[feed1_id]&feed=[feed2_id]\\` or \\`/miniflux/feeds=[feed1_id]&[feed2_id]\\`.\r\n    3. Additionally, you can use shorthand notation by directly using feed IDs: \\`/miniflux/[feed1_id]&[feed2_id]\\`.\r\n3. Further customization options are available based on your needs:\r\n    1. All parameters/options provided by MiniFlux are supported ([link](https://miniflux.app/docs/api.html#endpoint-get-feed-entries)). As noted in their documentation, multiple filtering options should be connected with \\`&\\`. Except for \\`status\\`, only the first occurrence of duplicate filter options will be considered.\r\n    2. Specifically, this route defaults to sorting entries from new to old (\\`direction=desc\\`).\r\n    3. Moreover, this route supports additional options including:\r\n        - Using the \\`feed_name\\` parameter to control title formatting; setting \\`feed_name=1\\` will display each title as \"Article Title | Feed Name,\" while default is set at \\`0\\`, showing only article titles.\r\n        - Utilizing the \\`mark\\` parameter to specify actions after fetching subscriptions in RSSHub, such as maintaining unchanged state (\\`unchanged\\`, default), marking as read (\\`read\\`), removing (\\`removed\\`) or marking as unread (\\`unread\\`). Note that marking as read should not simply be understood as a means for implementing synchronization services; rather, it functions more like an aid for MiniFlux's automatic cleaning feature.\r\n        - Future support may include utilizing the \\`link\\` parameter to control output URLs (this functionality requires corresponding interfaces from MiniFlux). It could involve generating URLs through MiniFlux entity sharing features or original content links.\r\n        - The output content quantity can be controlled via the 'limit' parameter; although all matching contents are typically outputted by default, **it is recommended that users set this parameter**.\r\n    `,\r\n    categories: ['other'],\r\n    example: '/miniflux/feeds=1&2&3/mark=read&limit=7&status=unread',\r\n    parameters: {\r\n        feeds: 'Subscribe source ID or get all.',\r\n        parameters: 'Filter and set parameters, use `&` to connect multiple.',\r\n    },\r\n    features: {\r\n        requireConfig: [\r\n            {\r\n                name: 'MINIFLUX_INSTANCE',\r\n                description: 'The instance used by the user, by default, is the official MiniFlux [paid service address](https://reader.miniflux.app)',\r\n            },\r\n            {\r\n                name: 'MINIFLUX_TOKEN',\r\n                description: \"User's API key, please log in to the instance used and go to `Settings` -> `API Key` -> `Create a new API key` to obtain.\",\r\n            },\r\n        ],\r\n        requirePuppeteer: false,\r\n        antiCrawler: false,\r\n        supportBT: false,\r\n        supportPodcast: false,\r\n        supportScihub: false,\r\n    },\r\n    name: 'Feed entry',\r\n    maintainers: ['emdoe', 'DIYgod'],\r\n    handler,\r\n};\r\n\r\nasync function handler(ctx) {\r\n    // Unchanged entries status after fetching.\r\n    // mark = unchanged | read | removed | unread\r\n    let mark = 'unchanged';\r\n    // Return shared link as default behavior\r\n    // link = shared | original\r\n    // let link = 'shared';\r\n    // Add feed's name to each article, default is off.\r\n    let addFeedName = 0;\r\n    // Here we use `limit` to temporarily store the limit number.\r\n    let limit = 0;\r\n\r\n    const instance = config.miniflux.instance;\r\n    const token = config.miniflux.token;\r\n\r\n    if (!token) {\r\n        throw new ConfigNotFoundError('This RSS feed is disabled due to its incorrect configuration: the token is missing.');\r\n    }\r\n\r\n    // In this function, var`mark`, `link`, and `limit`, `addFeedName`\r\n    // could be changed.\r\n    function filterHandler(item) {\r\n        if (item.search('=') === -1) {\r\n            return '';\r\n        }\r\n\r\n        const filter = item.slice(0, item.indexOf('='));\r\n        const option = item.slice(item.lastIndexOf('=') + 1);\r\n\r\n        switch (filter) {\r\n            case 'mark':\r\n                if ((option === 'read' || option === 'removed' || option === 'unread') && !setMark.length) {\r\n                    mark = option;\r\n                    setMark.push(1);\r\n                }\r\n                item = '';\r\n                break;\r\n            // case 'link':\r\n            //     (option == 'original') ?\r\n            //         link = option :\r\n            //         link = 'shared';\r\n            //     item = '';\r\n            //     break;\r\n            case 'feed_name':\r\n                if (Number.parseInt(option) === 1 && !setFeedName.length) {\r\n                    addFeedName = 1;\r\n                    setFeedName.push(1);\r\n                }\r\n                item = '';\r\n                break;\r\n            case 'direction':\r\n                if (option !== 'asc') {\r\n                    item = 'direction=desc';\r\n                }\r\n                break;\r\n            // If user mistakenly set `category=Int`\r\n            case 'category':\r\n                Number.isNaN(Number.parseInt(option)) ? (item = '') : (item = `category_id=${option}`);\r\n                break;\r\n            case 'order':\r\n                if (option !== 'id' && option !== 'category_title' && option !== 'published_at' && option !== 'status' && option !== 'category_id') {\r\n                    item = '';\r\n                }\r\n                break;\r\n            // Program should behave differently for `limit` parameter in\r\n            // each mode. So currently we only save the (last & existed)\r\n            // parameter, since user may mistakenly input this parameter\r\n            // several times.\r\n            case 'limit':\r\n                if (!Number.isNaN(option) && !setLimit.length) {\r\n                    limit = option;\r\n                    setLimit.push(1);\r\n                }\r\n                item = '';\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return item;\r\n    }\r\n\r\n    const entriesID = [];\r\n    const feedsName = [];\r\n    const articles = [];\r\n\r\n    // MiniFlux will only preserve the *first* valid filter option\r\n    // for each parameter, in order to matching the default behavior\r\n    // here we use arrays to track the setting for `limit`,\r\n    // `mark` and `feed_name`.\r\n    const setLimit = [];\r\n    const setMark = [];\r\n    const setFeedName = [];\r\n\r\n    const feeds = ctx.req.param('feeds');\r\n\r\n    let parameters = ctx.req.param('parameters');\r\n    // Set default direction\r\n    if (parameters.search('direction=') === -1) {\r\n        parameters += '&direction=desc';\r\n    }\r\n\r\n    parameters = parameters\r\n        .split('&')\r\n        .map((item) => filterHandler(item))\r\n        .filter(Boolean)\r\n        .join('&');\r\n\r\n    let queryLimit = ctx.req.query('limit');\r\n    let result: Data;\r\n    if (feeds.search(/feeds?=/g) !== -1 || !Number.isNaN(Number.parseInt(feeds.split('&').join('')))) {\r\n        const feedsID = feeds.replaceAll(/feeds?=/g, '');\r\n        const feedsList = [feedsID.split('&')].flat();\r\n\r\n        if (limit && queryLimit) {\r\n            if (limit < queryLimit) {\r\n                queryLimit = limit * feedsList.length;\r\n            } else {\r\n                const eachLimit = Number.parseInt(queryLimit / feedsList.length);\r\n                if (eachLimit) {\r\n                    limit = eachLimit;\r\n                } else {\r\n                    limit = 1;\r\n                    queryLimit = feedsList.length;\r\n                }\r\n            }\r\n            parameters += `&limit=${limit}`;\r\n        } else if (limit) {\r\n            parameters += `&limit=${limit}`;\r\n        } else if (queryLimit) {\r\n            const eachLimit = Number.parseInt(queryLimit / feedsList.length);\r\n            if (eachLimit) {\r\n                limit = eachLimit;\r\n            } else {\r\n                limit = 1;\r\n                queryLimit = feedsList.length;\r\n            }\r\n            parameters += `&limit=${limit}`;\r\n        }\r\n\r\n        await Promise.all(\r\n            feedsList.map(async (feed) => {\r\n                const url = `${instance}/v1/feeds/${feed}/entries?${parameters}`;\r\n                const response = await got({\r\n                    method: 'get',\r\n                    url,\r\n                    headers: {\r\n                        'X-Auth-Token': token,\r\n                    },\r\n                });\r\n\r\n                const entries = response.data.entries;\r\n                // Whether or not get the title of this feed\r\n                let getFeedTitle = 0;\r\n                // entries.map(item => {\r\n                for (const entry of entries) {\r\n                    entriesID.push(entry.id);\r\n                    if (!getFeedTitle) {\r\n                        feedsName.push(entry.feed.title);\r\n                        getFeedTitle = 1;\r\n                    }\r\n                    // Whether or not user would like to add the feed's name\r\n                    // to the title of article.\r\n                    let entryTitle = entry.title;\r\n                    if (addFeedName) {\r\n                        entryTitle += ` | ${entry.feed.title}`;\r\n                    }\r\n                    // let entryURL = `${instance}/share/${entry.share_code}`;\r\n                    // if (link == 'original') {\r\n                    //     entryURL = entry.url;\r\n                    // }\r\n                    articles.push({\r\n                        title: entryTitle,\r\n                        author: entry.author,\r\n                        pubDate: entry.published_at,\r\n                        description: entry.content,\r\n                        link: entry.url,\r\n                    });\r\n                }\r\n            })\r\n        );\r\n\r\n        const feedsNumber = feedsName.length;\r\n        let agTitle, agInfo;\r\n        if (feedsNumber > 2) {\r\n            agTitle = `MiniFlux | Aggregator For ${feedsNumber} Feeds`;\r\n            agInfo = 'An aggregator powered by MiniFlux and RSSHub. ' + 'This aggregator truthfully preserves the contents in ' + `${feedsNumber} feeds, including: ` + `<li>${feedsName.join('<li></li>')}</li>`;\r\n        } else if (feedsNumber) {\r\n            agTitle = `MiniFlux | ${feedsName.join(', ')}`;\r\n            agInfo = 'A RSS feed powered by MiniFlux and RSSHub ' + 'effortlessly republishes the contents in ' + `\"${feedsName.join('\" & \"')}\".`;\r\n        } else {\r\n            agTitle = `MiniFlux | Feeds Aggregator`;\r\n            agInfo = 'An aggregator powered by MiniFlux and RSSHub ' + 'with empty content. If this is not your intention, ' + `please double-check your setting for parameters.`;\r\n        }\r\n\r\n        result = {\r\n            title: agTitle,\r\n            link: instance,\r\n            description: agInfo,\r\n            item: articles,\r\n            allowEmpty: true,\r\n        };\r\n    } else {\r\n        if (limit && queryLimit) {\r\n            if (limit < queryLimit) {\r\n                queryLimit = limit;\r\n            }\r\n            // Here we could add a '&' since parameter(s) list must not empty.\r\n            parameters += `&limit=${queryLimit}`;\r\n        } else if (queryLimit) {\r\n            parameters += `&limit=${queryLimit}`;\r\n        } else if (limit) {\r\n            parameters += `&limit=${limit}`;\r\n        }\r\n\r\n        const response = await got.get(`${instance}/v1/entries?${parameters}`, {\r\n            headers: { 'X-Auth-Token': token },\r\n        });\r\n\r\n        const entries = response.data.entries;\r\n        const articles = [];\r\n        for (const entry of entries) {\r\n            entriesID.push(entry.id);\r\n            let entryTitle = entry.title;\r\n            if (addFeedName) {\r\n                entryTitle += ` | ${entry.feed.title}`;\r\n            }\r\n            // let entryURL = `${instance}/share/${entry.share_code}`;\r\n            // if (link == 'original') {\r\n            //     entryURL = entry.url;\r\n            // }\r\n            articles.push({\r\n                title: entryTitle,\r\n                author: entry.author,\r\n                pubDate: entry.published_at,\r\n                description: entry.content,\r\n                link: entry.url,\r\n            });\r\n        }\r\n\r\n        result = {\r\n            title: `MiniFlux | All`,\r\n            link: instance,\r\n            description: `All feeds on ${instance} powered by MiniFlux`,\r\n            item: articles,\r\n            allowEmpty: true,\r\n        };\r\n    }\r\n\r\n    if (mark !== 'unchanged') {\r\n        got({\r\n            method: 'put',\r\n            url: `${instance}/v1/entries`,\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'X-Auth-Token': token,\r\n            },\r\n            json: {\r\n                entry_ids: entriesID,\r\n                status: mark,\r\n            },\r\n        });\r\n    }\r\n\r\n    return result;\r\n}\r\n"],"mappings":"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"}