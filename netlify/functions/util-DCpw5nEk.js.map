{"version":3,"file":"util-DCpw5nEk.js","names":[],"sources":["../../lib/routes/gcores/parser.ts","../../lib/routes/gcores/util.ts"],"sourcesContent":["import { art } from '@/utils/render';\r\n\r\nimport path from 'node:path';\r\n\r\ninterface Style {\r\n    [key: string]: string;\r\n}\r\n\r\ninterface BlockType {\r\n    element: string | undefined;\r\n    parentElement?: string;\r\n    aliasedElements?: string[];\r\n}\r\n\r\ninterface InlineStyleRange {\r\n    offset: number;\r\n    length: number;\r\n    style: string;\r\n}\r\n\r\ninterface EntityRange {\r\n    offset: number;\r\n    length: number;\r\n    key: number;\r\n}\r\n\r\ninterface Entity {\r\n    type: string;\r\n    mutability: string;\r\n    data: any;\r\n}\r\n\r\ninterface Block {\r\n    key: string;\r\n    text: string;\r\n    type: string;\r\n    depth: number;\r\n    inlineStyleRanges: InlineStyleRange[];\r\n    entityRanges: EntityRange[];\r\n    data: any;\r\n}\r\n\r\ninterface Content {\r\n    blocks: Block[];\r\n    entityMap: { [key: string]: Entity };\r\n}\r\n\r\nconst imageBaseUrl: string = 'https://image.gcores.com';\r\n\r\nconst STYLES: Readonly<Record<string, Style>> = {\r\n    BOLD: { fontWeight: 'bold' },\r\n    CODE: { fontFamily: 'monospace', wordWrap: 'break-word' },\r\n    ITALIC: { fontStyle: 'italic' },\r\n    STRIKETHROUGH: { textDecoration: 'line-through' },\r\n    UNDERLINE: { textDecoration: 'underline' },\r\n};\r\n\r\nconst BLOCK_TYPES: Readonly<Record<string, BlockType>> = {\r\n    'header-one': { element: 'h1' },\r\n    'header-two': { element: 'h2' },\r\n    'header-three': { element: 'h3' },\r\n    'header-four': { element: 'h4' },\r\n    'header-five': { element: 'h5' },\r\n    'header-six': { element: 'h6' },\r\n    'unordered-list-item': { element: 'li', parentElement: 'ul' },\r\n    'ordered-list-item': { element: 'li', parentElement: 'ol' },\r\n    blockquote: { element: 'blockquote' },\r\n    atomic: { element: undefined },\r\n    'code-block': { element: 'pre' },\r\n    unstyled: { element: 'p' },\r\n};\r\n\r\n/**\r\n * Creates a styled HTML fragment for a given text and style object.\r\n * @param text - The text content.\r\n * @param style - CSS styles as key-value pairs.\r\n * @returns HTML string with applied styles.\r\n */\r\nconst createStyledFragment = (text: string, style: Readonly<Style>): string => {\r\n    const styleString = Object.entries(style)\r\n        .map(([key, value]) => `${key.replaceAll(/([A-Z])/g, '-$1').toLowerCase()}: ${value}`)\r\n        .join('; ');\r\n    return `<span style=\"${styleString}\">${text}</span>`;\r\n};\r\n\r\n/**\r\n * Creates an HTML element for a given entity.\r\n * @param entity - The entity to create an element for.\r\n * @param text - The text content of the entity.\r\n * @returns HTML element string.\r\n */\r\nconst createEntityElement = (entity: Entity, text: string): string => {\r\n    switch (entity.type) {\r\n        case 'EMBED':\r\n            return entity.data.content.startsWith('http') ? `<a href=\"${entity.data.content}\" target=\"_blank\">${entity.data.content}</a>` : entity.data.content;\r\n        case 'IMAGE':\r\n            return art(path.join(__dirname, 'templates/description.art'), {\r\n                images: entity.data.path\r\n                    ? [\r\n                          {\r\n                              src: new URL(entity.data.path, imageBaseUrl).href,\r\n                              alt: entity.data.caption,\r\n                              width: entity.data.width,\r\n                              height: entity.data.height,\r\n                          },\r\n                      ]\r\n                    : undefined,\r\n            }).replaceAll('\\n', '');\r\n        case 'GALLERY':\r\n            if (!entity.data.images || !Array.isArray(entity.data.images)) {\r\n                return '';\r\n            }\r\n            return art(path.join(__dirname, 'templates/description.art'), {\r\n                images: entity.data.images.map((image: any) => ({\r\n                    src: new URL(image.path, imageBaseUrl).href,\r\n                    alt: image.caption ?? entity.data.caption,\r\n                    width: image.width,\r\n                    height: image.height,\r\n                })),\r\n            }).replaceAll('\\n', '');\r\n        case 'LINK':\r\n            return `<a href=\"${entity.data.url}\" target=\"_blank\">${text}</a>`;\r\n        case 'WIDGET':\r\n            return `<a href=\"${entity.data.url}\" target=\"_blank\">${entity.data.title}</a>`;\r\n        default:\r\n            return '';\r\n    }\r\n};\r\n\r\n/**\r\n * Parses a block into an HTML string with applied styles and entities.\r\n * @param block - The block to parse.\r\n * @param entityMap - The entity map.\r\n * @returns HTML string representing the block.\r\n */\r\nconst parseBlock = (block: Block, entityMap: Readonly<Record<string, Entity>>): string => {\r\n    const blockType = BLOCK_TYPES[block.type];\r\n    if (!blockType) {\r\n        return '';\r\n    }\r\n\r\n    const { text, inlineStyleRanges, entityRanges } = block;\r\n\r\n    // Combine and sort ranges\r\n    const combinedRanges: Array<{\r\n        offset: number;\r\n        length: number;\r\n        styles: Style[];\r\n        entity: Entity | null;\r\n    }> = [];\r\n\r\n    for (const range of inlineStyleRanges) {\r\n        combinedRanges.push({\r\n            ...range,\r\n            styles: [STYLES[range.style]],\r\n            entity: null,\r\n        });\r\n    }\r\n\r\n    for (const range of entityRanges) {\r\n        combinedRanges.push({\r\n            ...range,\r\n            styles: [],\r\n            entity: entityMap[range.key],\r\n        });\r\n    }\r\n\r\n    combinedRanges.sort((a, b) => a.offset - b.offset);\r\n\r\n    // Group ranges by offset and length\r\n    const groupedRangesMap = new Map<string, { offset: number; length: number; styles: Style[]; entities: Entity[] }>();\r\n    const groupedRanges: { offset: number; length: number; styles: Style[]; entities: Entity[] }[] = [];\r\n\r\n    for (const range of combinedRanges) {\r\n        const rangeKey = `${range.offset}-${range.length}`;\r\n        let existingRange = groupedRangesMap.get(rangeKey);\r\n        if (!existingRange) {\r\n            existingRange = {\r\n                offset: range.offset,\r\n                length: range.length,\r\n                styles: [],\r\n                entities: [],\r\n            };\r\n            groupedRangesMap.set(rangeKey, existingRange);\r\n            groupedRanges.push(existingRange);\r\n        }\r\n\r\n        if (range.styles.length > 0) {\r\n            existingRange.styles.push(...range.styles);\r\n        }\r\n        if (range.entity) {\r\n            existingRange.entities.push(range.entity);\r\n        }\r\n    }\r\n\r\n    // Apply styles and entities\r\n    const resultParts: string[] = [];\r\n    let lastOffset = 0;\r\n\r\n    for (const range of groupedRanges) {\r\n        resultParts.push(text.substring(lastOffset, range.offset));\r\n\r\n        let styledText = text.substring(range.offset, range.offset + range.length);\r\n\r\n        if (range.styles.length > 0) {\r\n            const combinedStyle: Style = {};\r\n            for (const style of range.styles) {\r\n                for (const [key, value] of Object.entries(style)) {\r\n                    combinedStyle[key] = value;\r\n                }\r\n            }\r\n            styledText = createStyledFragment(styledText, combinedStyle);\r\n        }\r\n\r\n        if (range.entities.length > 0) {\r\n            for (const entity of range.entities) {\r\n                styledText = createEntityElement(entity, styledText);\r\n            }\r\n        }\r\n\r\n        resultParts.push(styledText);\r\n        lastOffset = range.offset + range.length;\r\n    }\r\n\r\n    resultParts.push(text.slice(lastOffset));\r\n\r\n    return `${blockType.element ? `<${blockType.element}>` : ''}${resultParts.join('').replaceAll('\\n', '<br>')}${blockType.element ? `</${blockType.element}>` : ''}`;\r\n};\r\n\r\n/**\r\n * Parses a Content object into an HTML string.\r\n * @param content - The Content object to parse.\r\n * @returns HTML string representing the content.\r\n */\r\nconst parseContent = (content: Content): string => {\r\n    const { blocks, entityMap } = content;\r\n\r\n    if (!blocks || blocks.length === 0) {\r\n        return '';\r\n    }\r\n\r\n    const htmlParts: string[] = [];\r\n    let currentParent: string | undefined = undefined;\r\n    let parentContent: string[] = [];\r\n\r\n    for (const block of blocks) {\r\n        const blockType = BLOCK_TYPES[block.type];\r\n        if (!blockType) {\r\n            continue;\r\n        }\r\n\r\n        const parsedBlock = parseBlock(block, entityMap);\r\n\r\n        if (blockType.parentElement) {\r\n            if (currentParent === blockType.parentElement) {\r\n                parentContent.push(parsedBlock);\r\n            } else {\r\n                if (currentParent) {\r\n                    htmlParts.push(`<${currentParent}>${parentContent.join('')}</${currentParent}>`);\r\n                }\r\n                currentParent = blockType.parentElement;\r\n                parentContent = [parsedBlock];\r\n            }\r\n        } else {\r\n            if (currentParent) {\r\n                htmlParts.push(`<${currentParent}>${parentContent.join('')}</${currentParent}>`);\r\n                currentParent = undefined;\r\n                parentContent = [];\r\n            }\r\n            htmlParts.push(parsedBlock);\r\n        }\r\n    }\r\n\r\n    if (currentParent) {\r\n        htmlParts.push(`<${currentParent}>${parentContent.join('')}</${currentParent}>`);\r\n    }\r\n\r\n    return htmlParts.join('');\r\n};\r\n\r\nexport { parseContent };\r\n","import { type Data, type DataItem } from '@/types';\r\n\r\nimport { art } from '@/utils/render';\r\nimport ofetch from '@/utils/ofetch';\r\nimport { parseDate } from '@/utils/parse-date';\r\n\r\nimport { type CheerioAPI, load } from 'cheerio';\r\nimport path from 'node:path';\r\n\r\nimport { parseContent } from './parser';\r\n\r\nconst baseUrl: string = 'https://www.gcores.com';\r\nconst imageBaseUrl: string = 'https://image.gcores.com';\r\nconst audioBaseUrl: string = 'https://alioss.gcores.com';\r\n\r\nconst types: Set<string> = new Set(['radios', 'articles', 'news', 'videos', 'talks']);\r\n\r\nconst processItems = async (limit: number, query: any, apiUrl: string, targetUrl: string): Promise<Data> => {\r\n    const response = await ofetch(apiUrl, {\r\n        query: query ?? {\r\n            'page[limit]': limit,\r\n            sort: '-published-at',\r\n            include: 'category,user,media',\r\n            'filter[list-all]': 1,\r\n        },\r\n    });\r\n\r\n    const targetResponse = await ofetch(targetUrl);\r\n    const $: CheerioAPI = load(targetResponse);\r\n    const language = $('html').attr('lang') ?? 'zh-CN';\r\n\r\n    const included = response.included;\r\n    const data = [...response.data, ...included].filter((item) => types.has(item.type));\r\n\r\n    let items: DataItem[] = [];\r\n\r\n    items = data?.slice(0, limit).map((item): DataItem => {\r\n        const attributes = item.attributes;\r\n        const relationships = item.relationships;\r\n\r\n        const title: string = attributes.title;\r\n        const pubDate: number | string = attributes['published-at'];\r\n        const linkUrl: string | undefined = `${item.type}/${item.id}`;\r\n\r\n        const categoryObjs = [relationships?.category?.data, relationships?.tag?.data, relationships?.topic?.data].filter(Boolean);\r\n        const categories: string[] = categoryObjs\r\n            .map((obj) => {\r\n                const attributes = included.find((i) => i.type === obj.type && i.id === obj.id)?.attributes;\r\n                return attributes?.name ?? attributes?.title;\r\n            })\r\n            .filter(Boolean);\r\n\r\n        const authorObj = relationships?.user?.data;\r\n        const authorIncluded = authorObj ? included.find((i) => i.type === authorObj.type && i.id === authorObj.id) : undefined;\r\n        const authors: DataItem['author'] = authorIncluded\r\n            ? [\r\n                  {\r\n                      name: authorIncluded.attributes?.nickname,\r\n                      url: authorIncluded.id ? new URL(`${authorObj.type}/${authorIncluded.id}`, baseUrl).href : undefined,\r\n                      avatar: authorIncluded.thumb ? new URL(authorIncluded.thumb, imageBaseUrl).href : undefined,\r\n                  },\r\n              ]\r\n            : undefined;\r\n\r\n        const guid: string = `gcores-${item.id}`;\r\n        const image: string | undefined = (attributes.cover ?? attributes.thumb) ? new URL(attributes.cover ?? attributes.thumb, imageBaseUrl).href : undefined;\r\n        const updated: number | string = pubDate;\r\n\r\n        let processedItem: DataItem = {\r\n            title,\r\n            pubDate: pubDate ? parseDate(pubDate) : undefined,\r\n            link: new URL(linkUrl, baseUrl).href,\r\n            category: categories,\r\n            author: authors,\r\n            guid,\r\n            id: guid,\r\n            image,\r\n            banner: image,\r\n            updated: updated ? parseDate(updated) : undefined,\r\n            language,\r\n        };\r\n\r\n        let enclosureUrl: string | undefined;\r\n        let enclosureType: string | undefined;\r\n\r\n        const mediaAttrs = included.find((i) => i.id === relationships.media?.data?.id)?.attributes;\r\n\r\n        if (attributes['speech-path']) {\r\n            enclosureUrl = new URL(`uploads/audio/${attributes['speech-path']}`, audioBaseUrl).href;\r\n            enclosureType = `audio/${enclosureUrl?.split(/\\./).pop()}`;\r\n        } else if (mediaAttrs) {\r\n            if (mediaAttrs.audio) {\r\n                enclosureUrl = mediaAttrs.audio;\r\n                enclosureType = `audio/${enclosureUrl?.split(/\\./).pop()}`;\r\n            } else if (mediaAttrs['original-src']) {\r\n                enclosureUrl = mediaAttrs['original-src'];\r\n                enclosureType = `video/${enclosureUrl?.split(/\\?/).pop() ? (/^id=\\d+$/.test(enclosureUrl?.split(/\\?/).pop() as string) ? 'taptap' : enclosureUrl?.split(/\\./).pop()) : ''}`;\r\n            }\r\n        }\r\n\r\n        if (enclosureUrl) {\r\n            const enclosureLength: number = attributes.duration ? Number(attributes.duration) : 0;\r\n\r\n            processedItem = {\r\n                ...processedItem,\r\n                enclosure_url: enclosureUrl,\r\n                enclosure_type: enclosureType,\r\n                enclosure_title: title,\r\n                enclosure_length: enclosureLength,\r\n                itunes_duration: enclosureLength,\r\n                itunes_item_image: image,\r\n            };\r\n        }\r\n\r\n        const description: string = art(path.join(__dirname, 'templates/description.art'), {\r\n            images: attributes.cover\r\n                ? [\r\n                      {\r\n                          src: new URL(attributes.cover, imageBaseUrl).href,\r\n                          alt: title,\r\n                      },\r\n                  ]\r\n                : undefined,\r\n            audios:\r\n                enclosureType?.startsWith('audio') && enclosureUrl\r\n                    ? [\r\n                          {\r\n                              src: enclosureUrl,\r\n                              type: enclosureType,\r\n                          },\r\n                      ]\r\n                    : undefined,\r\n            videos:\r\n                enclosureType?.startsWith('video') && enclosureUrl\r\n                    ? [\r\n                          {\r\n                              src: enclosureUrl,\r\n                              type: enclosureType,\r\n                          },\r\n                      ]\r\n                    : undefined,\r\n            intro: attributes.desc || attributes.excerpt,\r\n            description: attributes.content ? parseContent(JSON.parse(attributes.content)) : undefined,\r\n        });\r\n\r\n        processedItem = {\r\n            ...processedItem,\r\n            title: title ?? $(description).text(),\r\n            description,\r\n            content: {\r\n                html: description,\r\n                text: description,\r\n            },\r\n        };\r\n\r\n        return processedItem;\r\n    });\r\n\r\n    const title: string = $('title').text();\r\n\r\n    return {\r\n        title,\r\n        description: $('meta[name=\"description\"]').attr('content'),\r\n        link: targetUrl,\r\n        item: items,\r\n        allowEmpty: true,\r\n        author: title.split(/\\|/).pop()?.trim(),\r\n        language,\r\n        id: $('meta[property=\"og:url\"]').attr('content'),\r\n    };\r\n};\r\n\r\nexport { baseUrl, imageBaseUrl, audioBaseUrl, processItems };\r\n"],"mappings":"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"}