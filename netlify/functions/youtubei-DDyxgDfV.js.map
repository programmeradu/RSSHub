{"version":3,"file":"youtubei-DDyxgDfV.js","names":["cache","utils"],"sources":["../../lib/routes/youtube/api/youtubei.ts"],"sourcesContent":["import { getSubtitles } from 'youtube-caption-extractor';\r\nimport cache from '@/utils/cache';\r\nimport { Innertube } from 'youtubei.js';\r\nimport utils, { getVideoUrl } from '../utils';\r\nimport { Data } from '@/types';\r\nimport { parseRelativeDate } from '@/utils/parse-date';\r\n\r\nconst innertubePromise = Innertube.create();\r\n\r\nfunction pad(n: number, width: number = 2) {\r\n    return String(n).padStart(width, '0');\r\n}\r\n\r\nfunction toSrtTime(seconds: number): string {\r\n    const totalMs = Math.floor(seconds * 1000);\r\n    const hours = Math.floor(totalMs / 3_600_000);\r\n    const minutes = Math.floor((totalMs % 3_600_000) / 60000);\r\n    const secs = Math.floor((totalMs % 60000) / 1000);\r\n    const millis = totalMs % 1000;\r\n    return `${pad(hours)}:${pad(minutes)}:${pad(secs)},${pad(millis, 3)}`;\r\n}\r\n\r\ntype Subtitle = {\r\n    start: string;\r\n    dur: string;\r\n    text: string;\r\n};\r\n\r\nfunction convertToSrt(segments: Subtitle[]): string {\r\n    return segments\r\n        .map((seg, index) => {\r\n            const start = Number.parseFloat(seg.start);\r\n            const end = start + Number.parseFloat(seg.dur);\r\n            return `${index + 1}\r\n${toSrtTime(start)} --> ${toSrtTime(end)}\r\n${seg.text}\r\n`;\r\n        })\r\n        .join('\\n');\r\n}\r\n\r\nexport const getChannelIdByUsername = (username: string) =>\r\n    cache.tryGet(`youtube:getChannelIdByUsername:${username}`, async () => {\r\n        const innertube = await innertubePromise;\r\n        const navigationEndpoint = await innertube.resolveURL(`https://www.youtube.com/${username}`);\r\n        return navigationEndpoint.payload.browseId;\r\n    });\r\n\r\nexport const getDataByUsername = async ({ username, embed, filterShorts }: { username: string; embed: boolean; filterShorts: boolean }): Promise<Data> => {\r\n    const channelId = (await getChannelIdByUsername(username)) as string;\r\n    return getDataByChannelId({ channelId, embed, filterShorts });\r\n};\r\n\r\nconst getSubtitlesByVideoId = (videoId: string) =>\r\n    cache.tryGet(`youtube:getSubtitlesByVideoId:${videoId}`, async () => {\r\n        const subtitles = await getSubtitles({ videoID: videoId });\r\n        const srt = convertToSrt(subtitles);\r\n        return srt;\r\n    });\r\n\r\nexport const getDataByChannelId = async ({ channelId, embed }: { channelId: string; embed: boolean; filterShorts: boolean }): Promise<Data> => {\r\n    const innertube = await innertubePromise;\r\n    const channel = await innertube.getChannel(channelId);\r\n    const videos = await channel.getVideos();\r\n\r\n    return {\r\n        title: `${channel.metadata.title || channelId} - YouTube`,\r\n        link: `https://www.youtube.com/channel/${channelId}`,\r\n        image: channel.metadata.avatar?.[0].url,\r\n        description: channel.metadata.description,\r\n\r\n        item: await Promise.all(\r\n            videos.videos\r\n                .filter((video) => 'video_id' in video)\r\n                .map(async (video) => {\r\n                    const srt = await getSubtitlesByVideoId(video.video_id);\r\n                    const dataUrl = `data:text/plain;charset=utf-8,${srt}`;\r\n\r\n                    const img = 'best_thumbnail' in video ? video.best_thumbnail?.url : 'thumbnails' in video ? video.thumbnails?.[0]?.url : undefined;\r\n\r\n                    return {\r\n                        title: video.title.text || `YouTube Video ${video.video_id}`,\r\n                        description: 'description_snippet' in video ? utils.renderDescription(embed, video.video_id, img, utils.formatDescription(video.description_snippet?.toHTML())) : null,\r\n                        link: `https://www.youtube.com/watch?v=${video.video_id}`,\r\n                        author: typeof video.author === 'string' ? video.author : video.author.name === 'N/A' ? undefined : video.author.name,\r\n                        image: img,\r\n                        pubDate: 'published' in video && video.published?.text ? parseRelativeDate(video.published.text) : undefined,\r\n                        attachments: [\r\n                            {\r\n                                url: getVideoUrl(video.video_id),\r\n                                mime_type: 'text/html',\r\n                                duration_in_seconds: video.duration && 'seconds' in video.duration ? video.duration.seconds : undefined,\r\n                            },\r\n                            {\r\n                                url: dataUrl,\r\n                                mime_type: 'text/srt',\r\n                                title: 'Subtitles',\r\n                            },\r\n                        ],\r\n                    };\r\n                })\r\n        ),\r\n    };\r\n};\r\n\r\nexport const getDataByPlaylistId = async ({ playlistId, embed }: { playlistId: string; embed: boolean }): Promise<Data> => {\r\n    const innertube = await innertubePromise;\r\n    const playlist = await innertube.getPlaylist(playlistId);\r\n    const videos = await playlist.videos;\r\n\r\n    return {\r\n        title: `${playlist.info.title || playlistId} by ${playlist.info.author.name} - YouTube`,\r\n        link: `https://www.youtube.com/playlist?list=${playlistId}`,\r\n        image: playlist.info.thumbnails?.[0].url,\r\n        description: playlist.info.description || `${playlist.info.title} by ${playlist.info.author.name}`,\r\n\r\n        item: videos\r\n            .filter((video) => 'id' in video)\r\n            .map((video) => {\r\n                const img = 'best_thumbnail' in video ? video.best_thumbnail?.url : video.thumbnails?.[0]?.url;\r\n\r\n                return {\r\n                    title: video.title.text || `YouTube Video ${video.id}`,\r\n                    description: utils.renderDescription(embed, video.id, img, ''),\r\n                    link: `https://www.youtube.com/watch?v=${video.id}`,\r\n                    pubDate: 'published' in video && video.published?.text ? parseRelativeDate(video.published.text) : undefined,\r\n                    author:\r\n                        'author' in video\r\n                            ? [\r\n                                  {\r\n                                      name: video.author.name,\r\n                                      url: video.author.url,\r\n                                      avatar: video.author.thumbnails?.[0]?.url,\r\n                                  },\r\n                              ]\r\n                            : undefined,\r\n                    image: img,\r\n                    attachments: [\r\n                        {\r\n                            url: getVideoUrl(video.id),\r\n                            mime_type: 'text/html',\r\n                            duration_in_seconds: 'duration' in video && video.duration && 'seconds' in video.duration ? video.duration.seconds : undefined,\r\n                        },\r\n                    ],\r\n                };\r\n            }),\r\n    };\r\n};\r\n"],"mappings":"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"}