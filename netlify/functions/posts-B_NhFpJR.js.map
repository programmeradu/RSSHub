{"version":3,"file":"posts-B_NhFpJR.js","names":["getAccessToken: () => Promise<string | null>","accessToken: string | null","cache","generateAuthHeaders: () => Promise<{ Authorization?: string }>","generateAuthParams: () => { apiKey?: string }","processPost: (post: any) => DataItem","tokenRefresher: () => Promise<string | null>","got","route: Route","ConfigNotFoundError","got","utils"],"sources":["../../lib/routes/tumblr/utils.ts","../../lib/routes/tumblr/posts.ts"],"sourcesContent":["import { parseDate } from '@/utils/parse-date';\r\nimport { DataItem } from '@/types';\r\nimport { config } from '@/config';\r\nimport cache from '@/utils/cache';\r\nimport logger from '@/utils/logger';\r\nimport got from '@/utils/got';\r\n\r\nconst getAccessToken: () => Promise<string | null> = async () => {\r\n    let accessToken: string | null = await cache.get('tumblr:accessToken', false);\r\n    if (!accessToken) {\r\n        try {\r\n            const newAccessToken = await tokenRefresher();\r\n            if (newAccessToken) {\r\n                accessToken = newAccessToken;\r\n            }\r\n        } catch (error) {\r\n            // Return the `accessToken=null` value to indicate that the token is not available. Calls will only use the `apiKey` as a fallback to maybe hit non \"dashborad only\" blogs.\r\n            logger.error('Failed to refresh Tumblr token, using only client id as fallback', error);\r\n        }\r\n    }\r\n    return accessToken;\r\n};\r\n\r\nconst generateAuthHeaders: () => Promise<{ Authorization?: string }> = async () => {\r\n    const accessToken = await getAccessToken();\r\n    if (!accessToken) {\r\n        return {};\r\n    }\r\n    return {\r\n        Authorization: `Bearer ${accessToken}`,\r\n    };\r\n};\r\n\r\nconst generateAuthParams: () => { apiKey?: string } = () => ({\r\n    apiKey: config.tumblr.clientId,\r\n});\r\n\r\nconst processPost: (post: any) => DataItem = (post) => {\r\n    let description = '';\r\n\r\n    switch (post.type) {\r\n        case 'text':\r\n            description = post.body;\r\n            break;\r\n        case 'photo':\r\n            for (const photo of post.photos ?? []) {\r\n                description += `<img src=\"${photo.original_size.url}\"/><br/>`;\r\n            }\r\n            break;\r\n        case 'link':\r\n            description = post.url;\r\n            break;\r\n        case 'audio':\r\n            description = post.embed;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    return {\r\n        id: post.id_string,\r\n        title: post.summary ?? `New post from ${post.blog_name}`,\r\n        link: post.post_url,\r\n        pubDate: parseDate(post.timestamp * 1000),\r\n        category: post.tags,\r\n        description,\r\n    };\r\n};\r\n\r\nlet tokenRefresher: () => Promise<string | null> = () => Promise.resolve(null);\r\nif (config.tumblr && config.tumblr.clientId && config.tumblr.clientSecret && config.tumblr.refreshToken) {\r\n    tokenRefresher = async (): Promise<string | null> => {\r\n        let refreshToken = config.tumblr.refreshToken;\r\n\r\n        // Restore already refreshed tokens\r\n        const previousRefreshTokenSerialized = await cache.get('tumblr:refreshToken', false);\r\n        if (previousRefreshTokenSerialized) {\r\n            const previousRefreshToken = JSON.parse(previousRefreshTokenSerialized);\r\n            if (previousRefreshToken.startToken === refreshToken) {\r\n                refreshToken = previousRefreshToken.currentToken;\r\n            }\r\n        }\r\n        const response = await got.post('https://api.tumblr.com/v2/oauth2/token', {\r\n            form: {\r\n                grant_type: 'refresh_token',\r\n                client_id: config.tumblr.clientId,\r\n                client_secret: config.tumblr.clientSecret,\r\n                refresh_token: refreshToken,\r\n            },\r\n        });\r\n        if (!response.data?.access_token || !response.data?.refresh_token) {\r\n            return null;\r\n        }\r\n        const accessToken = response.data.access_token;\r\n        const newRefreshToken = response.data.refresh_token;\r\n        const expiresIn = response.data.expires_in;\r\n\r\n        // Access tokens expire after 42 minutes, remove 30 seconds to renew the token before it expires (to avoid making a request right when it ends).\r\n        await cache.set('tumblr:accessToken', accessToken, (expiresIn ?? 2520) - 30);\r\n        // Store the new refresh token associated with the one that was provided first.\r\n        // We may be able to restore the new token if the app is restarted. This will avoid reusing the old token and have a failing request.\r\n        // Keep it for a year (not clear how long the refresh token lasts).\r\n        const cacheEntry = { startToken: config.tumblr.refreshToken, currentToken: newRefreshToken };\r\n        await cache.set(`tumblr:refreshToken`, JSON.stringify(cacheEntry), 31_536_000);\r\n\r\n        return accessToken;\r\n    };\r\n}\r\n\r\nexport default { processPost, generateAuthParams, generateAuthHeaders };\r\n","import { Data, Route } from '@/types';\r\nimport got from '@/utils/got';\r\nimport utils from './utils';\r\nimport type { Context } from 'hono';\r\nimport { config } from '@/config';\r\nimport ConfigNotFoundError from '@/errors/types/config-not-found';\r\nimport { fallback, queryToInteger } from '@/utils/readable-social';\r\n\r\nexport const route: Route = {\r\n    path: '/posts/:blog',\r\n    categories: ['blog'],\r\n    example: '/tumblr/posts/biketouring-nearby',\r\n    parameters: {\r\n        blog: 'Blog identifier (see `https://www.tumblr.com/docs/en/api/v2#blog-identifiers`)',\r\n    },\r\n    radar: [],\r\n    features: {\r\n        requireConfig: [\r\n            {\r\n                name: 'TUMBLR_CLIENT_ID',\r\n                description: 'Please see above for details.',\r\n            },\r\n            {\r\n                name: 'TUMBLR_CLIENT_SECRET',\r\n                description: 'Please see above for details.',\r\n            },\r\n            {\r\n                name: 'TUMBLR_REFRESH_TOKEN',\r\n                description: 'Please see above for details.',\r\n            },\r\n        ],\r\n        requirePuppeteer: false,\r\n        antiCrawler: false,\r\n        supportBT: false,\r\n        supportPodcast: false,\r\n        supportScihub: false,\r\n    },\r\n    name: 'Posts',\r\n    maintainers: ['Rakambda'],\r\n    description: `::: tip\r\nTumblr provides official RSS feeds for non \"dashboard only\" blogs, for instance [https://biketouring-nearby.tumblr.com](https://biketouring-nearby.tumblr.com/rss).\r\n:::`,\r\n    handler,\r\n};\r\n\r\nasync function handler(ctx: Context): Promise<Data> {\r\n    if (!config.tumblr || !config.tumblr.clientId) {\r\n        throw new ConfigNotFoundError('Tumblr RSS is disabled due to the lack of <a href=\"https://docs.rsshub.app/deploy/config#route-specific-configurations\">relevant config</a>');\r\n    }\r\n\r\n    const blogIdentifier = ctx.req.param('blog');\r\n    const limit = fallback(undefined, queryToInteger(ctx.req.query('limit')), 20);\r\n\r\n    const response = await got.get(`https://api.tumblr.com/v2/blog/${blogIdentifier}/posts`, {\r\n        searchParams: {\r\n            ...utils.generateAuthParams(),\r\n            limit,\r\n        },\r\n        headers: await utils.generateAuthHeaders(),\r\n    });\r\n\r\n    const blog = response.data.response.blog;\r\n    const posts = response.data.response.posts.map((post: any) => utils.processPost(post));\r\n\r\n    return {\r\n        title: `Tumblr - ${blogIdentifier} - Posts`,\r\n        author: blog?.name,\r\n        link: blog?.url ?? `https://${blogIdentifier}/`,\r\n        item: posts,\r\n        allowEmpty: true,\r\n        image: blog?.avatar?.slice(-1)?.url,\r\n        description: blog?.description,\r\n    };\r\n}\r\n"],"mappings":"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"}